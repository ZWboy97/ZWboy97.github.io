<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【学习笔记】Three.js以及三维技术学习</title>
      <link href="/ji-zhu/bi-ji-three-js-xue-xi.html"/>
      <url>/ji-zhu/bi-ji-three-js-xue-xi.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>背景知识</p><ul><li>视频云项目又有了开发XR应用的需求了，就是实现各种AR、VR、全景视频直播等效果。Three.js是Web端进行3D展示的工具库，它对底层的WebGL进行了封装，大大简化了3D的开发。</li><li>Three.js入门学习时候的难点在于对Three.js以及三维建模领域一些关键概念的理解，本文主要以梳理Three.js中的核心概念为主。对于Three.js中的各个核心概念，通过Best Practice的形式快速了解其用途和能力。</li><li>本文追求系统性，不追求细节。旨在快速建立对Three.js整体的概念了解，能够快速看懂和利用好官方文档。</li></ul></blockquote><h3 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h3><ul><li>场景：scene，其中可以添加object</li><li>相机：camera，对scene中的内容进行拍摄</li><li>渲染器：render，对相机拍到的画面进行渲染</li><li>网格模型：mesh，</li><li>材质：material，</li><li>几何体：geometry，</li><li>点光源：PointLight，</li><li>环境光：AmbientLight，</li></ul><a id="more"></a><h5 id="场景Scene"><a href="#场景Scene" class="headerlink" title="场景Scene"></a>场景Scene</h5><ul><li>sence：场景</li></ul><pre><code class="js">    var scene = new THREE.Scene(); // 创建场景    scene.add(mesh); //网格模型添加到场景中</code></pre><h5 id="几何体Geometry"><a href="#几何体Geometry" class="headerlink" title="几何体Geometry"></a>几何体Geometry</h5><ul><li>几何框架</li></ul><pre><code class="js">    //立方体 参数：长，宽，高    var geometry = new THREE.BoxGeometry(100, 100, 100);    // 球体 参数：半径60  经纬度细分数40,40    var geometry = new THREE.SphereGeometry(60, 40, 40);    //圆柱  参数：圆柱面顶部、底部直径50,50   高度100  圆周分段数    var geometry = new THREE.CylinderGeometry(50, 50, 100, 25);    // 正八面体    var geometry = new THREE.OctahedronGeometry(50);    // 正十二面体    var geometry = new THREE.DodecahedronGeometry(50);    // 正二十面体    var geometry = new THREE.IcosahedronGeometry(50);</code></pre><h5 id="材质Material"><a href="#材质Material" class="headerlink" title="材质Material"></a>材质Material</h5><ul><li><p>可以对几何体进行着色</p></li><li><p>本质：顶点着色器，可以被render解析加入计算</p></li><li><p>几种常用材质</p><ul><li>点材质</li><li>线材质</li><li>网格材质</li></ul></li></ul><pre><code class="js">    //基础网格材质对象   不受光照影响  没有棱角感    var material = new THREE.MeshBasicMaterial({        color: 0x0000ff,        wireframe:true,//线条模式渲染，线条编织成网    });    // 与光照计算  漫反射   产生棱角感    var material = new THREE.MeshLambertMaterial({color: 0x0000ff });     // 与光照计算  高光效果（镜面反射）产生棱角感    var material = new THREE.MeshPhongMaterial({        color: 0xff0000,        specular:0x444444, // 高光部分的颜色        shininess:30, // 高光部分的亮度      side:THREE.DoubleSide, // 前面FrontSide  背面：BackSide 双面：DoubleSide    });    // 透明材质    var material1 = new THREE.MeshLambertMaterial({      color: 0x0000ff,//材质颜色      transparent:true,//开启透明度      opacity:0.5,//设置透明度具体值    });    // 点渲染模式    var material = new THREE.PointsMaterial({      color: 0xff0000,      size: 5.0 //点对象像素尺寸    });    // 线条渲染模式    var material=new THREE.LineBasicMaterial({        color:0xff0000 //线条颜色    });</code></pre><h5 id="渲染模型"><a href="#渲染模型" class="headerlink" title="渲染模型"></a>渲染模型</h5><ul><li>由几何体参数+材质参数组成</li><li>与材质类似，也有三种<ul><li>点模型：Point</li><li>线模型：Line</li><li>网格模型：Mesh</li></ul></li></ul><pre><code class="js">    var mesh = new THREE.Mesh(geometry, material); //网格模型对象Mesh    scene.add(mesh); //网格模型添加到场景中    mesh.rotateY(0.01);         //绕y轴旋转0.01弧度    mesh.translateY(120);       //球体网格模型沿Y轴正方向平移120    mesh.position.set(120,0,0); //设置mesh3模型对象的xyz坐标为120,0,0    var point = new THREE.Points(geometry, material);    var line = new THREE.Line(geometry, material); //线模型对象</code></pre><ul><li>复制模型</li></ul><pre><code class="js">    var geometry2 = new THREE.BoxGeometry(30, 30, 30); //创建一个立方体几何对象Geometry    var material2 = new THREE.MeshLambertMaterial({      color: 0xff00ff    }); //材质对象Material    var newMesh = new THREE.Mesh(geometry2, material2);    // 复制mesh的位置、旋转、矩阵等属性(不包含geometry和material属性)    newMesh.copy(mesh);    //相比mesh而言，在平移    newMesh.translateX(-50);    scene.add(newMesh)</code></pre><h5 id="相机Camera"><a href="#相机Camera" class="headerlink" title="相机Camera"></a>相机Camera</h5><ul><li>远景相机（PerspectiveCamera），也就是类似于人眼观察的方式<ul><li>4个参数，决定了视椎体，用来裁剪视图，在该视锥体以外的物体将不会被渲染。<ul><li>FOV：视角（field of view）</li><li>aspect_radio:相机拍摄面的长宽比（aspect ratio）,一般使用元素的宽除以高，否则会出现挤压变形。</li><li>near_plane: 近裁剪面</li><li>far_plane: 远裁剪面</li></ul></li></ul></li></ul><pre><code class="js">    var width = window.innerWidth; //窗口宽度    var height = window.innerHeight; //窗口高度    var aspect = width / height; //窗口宽高比    var s = 200; //三维场景显示范围控制系数，系数越大，显示的范围越大    // 创建相机对象    var camera = new THREE.OrthographicCamera(-s * k, s * k, s, -s, 1, 1000);    // 创建远景相机,参数（FOV，aspect_radio,near_plane,far_plane）    var camera = new THREE.PerspectiveCamera( 75, aspect , 0.1, 1000 );    camera.position.set(200, 300, 200); //设置相机位置    camera.lookAt(scene.position); //设置相机方向(指向的场景对象)</code></pre><h5 id="渲染器Render"><a href="#渲染器Render" class="headerlink" title="渲染器Render"></a>渲染器Render</h5><ul><li>WebGLRenderer为主，也有其他渲染器，但以兼容性为主</li><li>WebGLRenderer，使用GPU进行渲染</li><li>render负责解析数据，然后</li></ul><pre><code class="js">    var renderer = new THREE.WebGLRenderer();    //设置渲染区域尺寸    renderer.setSize(window.innerWidth, window.innerHeight);    //设置背景颜色    renderer.setClearColor(0xb9d3ff, 1);     // 把 renderer 元素添加到HTML文档中。这里是一个 &lt;canvas&gt; 元素，渲染器用来显示场景    document.body.appendChild(renderer.domElement);    //执行渲染操作    renderer.render(scene, camera); // 只会渲染一次    // 循环渲染    function render() {      cube.rotation.x += 0.1; // 实现动画      cube.rotation.y += 0.1;      requestAnimationFrame( render ); // window的函数，以每秒60次的频率来绘制场景      renderer.render( scene, camera );    }    render();</code></pre><ul><li>requestAnimationFrame函数：它用来替代 setInterval， 这个新接口具备多个优点，比如浏览器Tab切换后停止渲染以节约资源、和屏幕刷新同步避免无效刷新、在不支持该接口的浏览器中能安全回退为setInterval</li></ul><h3 id="二、相机控制与交互"><a href="#二、相机控制与交互" class="headerlink" title="二、相机控制与交互"></a>二、相机控制与交互</h3><ul><li>Three.js提供了OrbitControls.js，直接控制相机</li></ul><pre><code class="js">    //创建控件对象  相机对象camera作为参数   控件可以监听鼠标的变化，改变相机对象的属性    var controls = new THREE.OrbitControls(camera,renderer.domElement);    //监听鼠标事件，触发渲染函数，更新canvas画布渲染效果    controls.addEventListener(&#39;change&#39;, render);</code></pre><ul><li>动画与交互同时控制</li></ul><pre><code class="js">    function render() {      renderer.render(scene, camera); //执行渲染操作      mesh.rotateY(0.01);//每次绕y轴旋转0.01弧度      requestAnimationFrame(render);//请求再次执行渲染函数render，渲染下一帧    }    render();    //创建控件对象  相机对象camera作为参数   控件可以监听鼠标的变化，改变相机对象的属性    var controls = new THREE.OrbitControls(camera,renderer.domElement);</code></pre><h3 id="三、顶点"><a href="#三、顶点" class="headerlink" title="三、顶点"></a>三、顶点</h3><h5 id="顶点概念"><a href="#顶点概念" class="headerlink" title="顶点概念"></a>顶点概念</h5><ul><li>顶点连接成线，线组成三角面，三角面组成更多类型的面，顶点具有position和color等基础属性</li><li>BufferGeometry是所有几何体的基类，可以为其赋予多种属性，来实现不同的效果。</li><li>主要是通过顶点数据来确定渲染的。</li></ul><pre><code class="js">    var geometry = new THREE.BufferGeometry(); //创建一个Buffer类型几何体对象    var vertices = new Float32Array([ //类型数组创建顶点数据      0, 0, 0, //顶点1坐标      50, 0, 0, //顶点2坐标      0, 50, 0, //顶点3坐标      0, 0, 10, //顶点4坐标      0, 0, 60, //顶点5坐标      50, 0, 10, //顶点6坐标    ]);    // 创建属性缓冲区对象    var attribue = new THREE.BufferAttribute(vertices, 3); //3个为一组，表示一个顶点的xyz坐标    // 设置几何体attributes属性的位置属性    geometry.attributes.position = attribue;    //类型数组创建顶点颜色color数据    var colors = new Float32Array([      1, 0, 0, //顶点1颜色      0, 1, 0, //顶点2颜色      0, 0, 1, //顶点3颜色      1, 1, 0, //顶点4颜色      0, 1, 1, //顶点5颜色      1, 0, 1, //顶点6颜色    ]);    // 设置几何体attributes属性的颜色color属性    geometry.attributes.color = new THREE.BufferAttribute(colors, 3); //3个为一组,表示一个顶点的颜色数据RGB      //材质对象    var material = new THREE.MeshBasicMaterial({      // 使用顶点颜色数据渲染模型，不需要再定义color属性      // color: 0xff0000,      vertexColors: THREE.VertexColors, //以顶点颜色为准,即试用上边指定的颜色数组    });</code></pre><h5 id="顶点法向量"><a href="#顶点法向量" class="headerlink" title="顶点法向量"></a>顶点法向量</h5><ul><li>参与光照的计算，对物体最终所呈现的实际颜色的有影响的。</li><li>法向量对应的属性为normal</li></ul><pre><code class="js">  var normals = new Float32Array([      0, 0, 1, //顶点1法向量      0, 0, 1, //顶点2法向量      0, 0, 1, //顶点3法向量      0, 1, 0, //顶点4法向量      0, 1, 0, //顶点5法向量      0, 1, 0, //顶点6法向量    ]);    // 设置几何体attributes属性的位置normal属性    geometry.attributes.normal = new THREE.BufferAttribute(normals, 3); //3个为一组,表示一个顶点的法向量数据</code></pre><h5 id="顶点数据复用与索引"><a href="#顶点数据复用与索引" class="headerlink" title="顶点数据复用与索引"></a>顶点数据复用与索引</h5><ul><li>渲染一个四边形，实际需要6个顶点，是通过两个三角面实现的。</li><li>其中第二个三角面的两个顶点与第一个重合，所以可以复用。</li><li>通过顶点的索引属性来指定，实现顶点数据的复用，对应的属性名为index。</li></ul><pre><code class="js">      // Uint16Array类型数组创建顶点索引数据    var indexes = new Uint16Array([      0, 1, 2, 0, 2, 3,    ])    // 索引数据赋值给几何体的index属性    geometry.index = new THREE.BufferAttribute(indexes, 1); //1个为一组</code></pre><h5 id="设置Geometry的顶点"><a href="#设置Geometry的顶点" class="headerlink" title="设置Geometry的顶点"></a>设置Geometry的顶点</h5><ul><li>相比BufferGeomerty<ul><li>他们的属性组织架构是不同的，但实现的效果是相同的</li><li>BufferGeomerty是基于缩影的渲染，而Geometry是基于三角面的方式。</li></ul></li><li>属性<ul><li>vertices属性，顶点坐标数据</li><li>colors属性，顶点颜色数据</li></ul></li></ul><pre><code class="js">    var geometry = new THREE.Geometry(); //声明一个几何体对象Geometry    // Vector3向量对象表示顶点位置数据    var p1 = new THREE.Vector3(50, 0, 0); //顶点1坐标    var p2 = new THREE.Vector3(0, 70, 0); //顶点2坐标    var p3 = new THREE.Vector3(80, 70, 0); //顶点3坐标    //顶点坐标添加到geometry对象    geometry.vertices.push(p1, p2, p3);    // Color对象表示顶点颜色数据    var color1 = new THREE.Color(0x00ff00); //顶点1颜色——绿色    var color2 = new THREE.Color(0xff0000); //顶点2颜色——红色    var color3 = new THREE.Color(0x0000ff); //顶点3颜色——蓝色    //顶点颜色数据添加到geometry对象    geometry.colors.push(color1, color2, color3);</code></pre><h5 id="Face3对象"><a href="#Face3对象" class="headerlink" title="Face3对象"></a>Face3对象</h5><ul><li>定义几何体的三角面</li></ul><pre><code class="js">    var geometry = new THREE.Geometry(); //声明一个几何体对象Geometry    var p1 = new THREE.Vector3(0, 0, 0); //顶点1坐标    var p2 = new THREE.Vector3(0, 100, 0); //顶点2坐标    var p3 = new THREE.Vector3(50, 0, 0); //顶点3坐标    var p4 = new THREE.Vector3(0, 0, 100); //顶点4坐标    //顶点坐标添加到geometry对象    geometry.vertices.push(p1, p2, p3, p4);    // Color对象表示顶点颜色数据    var color1 = new THREE.Color(0x00ff00); //顶点1颜色——绿色    var color2 = new THREE.Color(0xff0000); //顶点2颜色——红色    var color3 = new THREE.Color(0x0000ff); //顶点3颜色——蓝色    var color4 = new THREE.Color(0xffff00); //顶点3颜色——黄色    //顶点颜色数据添加到geometry对象    geometry.colors.push(color1, color2, color3, color4);    // Face3构造函数创建一个三角面    var face1 = new THREE.Face3(0, 1, 2);    //设置三角面face1每个顶点的法向量    var n1 = new THREE.Vector3(0, 0, -1);    var n2 = new THREE.Vector3(0, 0, -1);    var n3 = new THREE.Vector3(0, 0, -1);    // 设置三角面Face3三个顶点的法向量    face1.vertexNormals.push(n1, n2, n3);    // 设置三角面face1三个顶点的颜色    face1.vertexColors = [      new THREE.Color(0xffff00),      new THREE.Color(0xff00ff),      new THREE.Color(0x00ffff),    ]    // 三角面2    var face2 = new THREE.Face3(0, 2, 3);    // 设置三角面法向量    face2.normal = new THREE.Vector3(0, -1, 0);    face2.color = new THREE.Color(0x00ff00);    //三角面face1、face2添加到几何体中    geometry.faces.push(face1, face2);</code></pre><h5 id="几何体变换"><a href="#几何体变换" class="headerlink" title="几何体变换"></a>几何体变换</h5><ul><li>其实就是对顶点坐标进行变换</li></ul><pre><code class="js">    // 几何体xyz三个方向都放大2倍    geometry.scale(2, 2, 2);    // 几何体沿着x轴平移50    geometry.translate(50, 0, 0);    // 几何体绕着x轴旋转45度    geometry.rotateX(Math.PI / 4);    // 居中：偏移的几何体居中    geometry.center();</code></pre><h3 id="四、光源"><a href="#四、光源" class="headerlink" title="四、光源"></a>四、光源</h3><ul><li>可以与模型对象一起，添加到场景中</li><li>可以与材质的颜色进行计算，计算得到最终看到的颜色值</li><li>分类：<ul><li>环境光：无方向的光，其他都是有方向的</li><li>点光源</li><li>平行光源</li><li>聚光光源</li></ul></li></ul><h5 id="点光源PointLight"><a href="#点光源PointLight" class="headerlink" title="点光源PointLight"></a>点光源PointLight</h5><ul><li>add插入场景中，render的时候会获取光源的信息进行光照计算</li></ul><pre><code class="js">    //点光源    var point = new THREE.PointLight(0xffffff);    point.position.set(400, 200, 300); //点光源位置    scene.add(point); //点光源添加到场景中</code></pre><h5 id="环境光AmbientLight"><a href="#环境光AmbientLight" class="headerlink" title="环境光AmbientLight"></a>环境光AmbientLight</h5><ul><li>环境光颜色与网格模型的颜色进行RGB进行乘法运算</li><li>没有方向，所以没有明显的棱</li></ul><pre><code class="js">    //环境光    var ambient = new THREE.AmbientLight(0x444444);    scene.add(ambient);</code></pre><h5 id="聚光"><a href="#聚光" class="headerlink" title="聚光"></a>聚光</h5><pre><code class="js">    var spotLight = new THREE.SpotLight(0xffffff);    // 设置聚光光源位置    spotLight.position.set(200, 200, 200);    // 聚光灯光源指向网格模型mesh2    spotLight.target = mesh2;    // 设置聚光光源发散角度    spotLight.angle = Math.PI / 6    scene.add(spotLight);//光对象添加到scene场景中</code></pre><h5 id="平行光"><a href="#平行光" class="headerlink" title="平行光"></a>平行光</h5><pre><code class="js">    var directionalLight = new THREE.DirectionalLight(0xffffff, 1);    // 设置光源的方向：通过光源position属性和目标指向对象的position属性计算    // 注意：位置属性在这里不代表方向光的位置，你可以认为方向光没有位置    directionalLight.position.set(80, 100, 50);    // 方向光指向对象，可以不设置，默认的位置是0,0,0    directionalLight.target = mesh2;    scene.add(directionalLight);</code></pre><h5 id="添加阴影"><a href="#添加阴影" class="headerlink" title="添加阴影"></a>添加阴影</h5><ul><li>分两步<ul><li>1.开启模型的阴影</li><li>2.添加一个接收阴影的模型</li></ul></li></ul><pre><code class="js">    var mesh = new THREE.Mesh(geometry, material); //网格模型对象Mesh    scene.add(mesh); //网格模型添加到场景中    mesh.castShadow = true;    //创建一个平面几何体作为投影面    var planeGeometry = new THREE.PlaneGeometry(300, 200);    var planeMaterial = new THREE.MeshLambertMaterial({      color: 0x999999    }); //材质对象Material    // 平面网格模型作为投影面    var planeMesh = new THREE.Mesh(planeGeometry, planeMaterial); //网格模型对象Mesh    scene.add(planeMesh); //网格模型添加到场景中    planeMesh.receiveShadow = true;    planeMesh.rotateX(-Math.PI / 2)    planeMesh.position.y = -25;</code></pre><h3 id="五、组对象Group"><a href="#五、组对象Group" class="headerlink" title="五、组对象Group"></a>五、组对象Group</h3><ul><li>目的是方便批量处理，可以将多个模型对象组合成一个Group，然后对这个Group进行统一的处理。</li></ul><pre><code class="js">    var group1 = new THREE.Group();    var mesh = new THREE.Mesh(geometry, material);    group1.add(mesh); //把网格模型插入到组group1中    scene.add(group);</code></pre><h3 id="六、位置坐标"><a href="#六、位置坐标" class="headerlink" title="六、位置坐标"></a>六、位置坐标</h3><ul><li>本地与世界作保<ul><li>本地坐标：该模型对象属性中设置的坐标</li><li>世界坐标：一个模型对象可能还存在其他Group中，Group的坐标变化也会造成该模型对象的位置变化，最终该模型的坐标便是它的世界坐标。</li></ul></li><li>获得世界坐标的方法</li></ul><pre><code class="js">  scene.updateMatrixWorld(true); // 更新世界坐标矩阵，不可缺少  var worldPosition = new THREE.Vector3();  mesh.getWorldPosition(worldPosition)</code></pre><h3 id="七、纹理贴图"><a href="#七、纹理贴图" class="headerlink" title="七、纹理贴图"></a>七、纹理贴图</h3><h5 id="顶点UV映射数据"><a href="#顶点UV映射数据" class="headerlink" title="顶点UV映射数据"></a>顶点UV映射数据</h5><ul><li>3D模型除了有顶点坐标、颜色等属性外，还有一个顶点纹理UV数据，UV负责实现外部纹理与模型顶点之间的映射</li><li>对于常用的立方体、球体、平面等模型，内部已经具有了UV数据。</li><li>对于更复杂的3D模型，通过外部modle.json文件导入的方式导入模型，该json中会包括UV数据。</li></ul><h5 id="图片作为纹理"><a href="#图片作为纹理" class="headerlink" title="图片作为纹理"></a>图片作为纹理</h5><ul><li>通过TextureLoader加载一个图片，然后把图片数据作为纹理数据，传递给map属性即可。</li></ul><pre><code class="js">    var geometry = new THREE.BoxGeometry(100, 100, 100); //立方体    var geometry = new THREE.PlaneGeometry(204, 102); //矩形平面    var geometry = new THREE.SphereGeometry(60, 25, 25); //球体    // TextureLoader创建一个纹理加载器对象，可以加载图片作为几何体纹理    var textureLoader = new THREE.TextureLoader();    // 执行load方法，加载纹理贴图成功后，返回一个纹理对象Texture    textureLoader.load(&#39;Earth.png&#39;, function (texture) {      var material = new THREE.MeshLambertMaterial({        map: texture,        // 设置纹理贴图：Texture对象作为材质map属性的属性值      });      var mesh = new THREE.Mesh(geometry, material); //网格模型对象Mesh      scene.add(mesh); //网格模型添加到场景中    })</code></pre><h5 id="视频作为纹理"><a href="#视频作为纹理" class="headerlink" title="视频作为纹理"></a>视频作为纹理</h5><pre><code class="js">    var geometry = new THREE.PlaneGeometry(108, 71); //矩形平面    let video = document.createElement(&#39;video&#39;);     // 创建video对象    video.src = &quot;video.mp4&quot;; // 设置视频地址    video.autoplay = &quot;autoplay&quot;; //要设置播放    // video对象作为VideoTexture参数创建纹理对象    var texture = new THREE.VideoTexture(video)    var material = new THREE.MeshPhongMaterial({      map: texture, // 设置纹理贴图    });    var mesh = new THREE.Mesh(geometry, material); //网格模型对象Mesh    scene.add(mesh); //网格模型添加到场景中</code></pre><h5 id="纹理整列"><a href="#纹理整列" class="headerlink" title="纹理整列"></a>纹理整列</h5><ul><li>加载纹理之后，不断重复该纹理，即贴图效果。</li><li>实现草地效果</li></ul><pre><code class="js">    var geometry = new THREE.PlaneGeometry(1000, 1000); //矩形平面    var texture = new THREE.TextureLoader().load(&quot;grass.jpg&quot;);    texture.wrapS = THREE.RepeatWrapping;    texture.wrapT = THREE.RepeatWrapping;    texture.repeat.set(10, 10);     // uv两个方向纹理重复数量    var material = new THREE.MeshLambertMaterial({      map: texture,    });    var mesh = new THREE.Mesh(geometry, material); //网格模型对象Mesh    scene.add(mesh); //网格模型添加到场景中    mesh.rotateX(-Math.PI / 2);</code></pre><h3 id="八、相机"><a href="#八、相机" class="headerlink" title="八、相机"></a>八、相机</h3><ul><li>相机拍摄的过程其实就是进行投影计算的过程，我们看到的物体实际是一个三维物体在一个方向上的投影</li><li>分类<ul><li>正投影：没有近大远小效果，适用于小场景，一般用于三维设计或者零件展示。可视区域是一个立方体。</li><li>透视投影：近大远小效果，适用于大场景，比如游戏场景，可视区域是一个视锥体</li></ul></li></ul><h5 id="相机窗口自适应"><a href="#相机窗口自适应" class="headerlink" title="相机窗口自适应"></a>相机窗口自适应</h5><ul><li>透视相机自适应</li></ul><pre><code class="js">  window.onresize=function(){    // 重置渲染器输出画布canvas尺寸    renderer.setSize(window.innerWidth,window.innerHeight);    // 全屏情况下：设置观察范围长宽比aspect为窗口宽高比    camera.aspect = window.innerWidth/window.innerHeight;    // 渲染器执行render方法的时候会读取相机对象的投影矩阵属性projectionMatrix    // 但是不会每渲染一帧，就通过相机的属性计算投影矩阵(节约计算资源)    // 如果相机的一些属性发生了变化，需要执行updateProjectionMatrix ()方法更新相机的投影矩阵    camera.updateProjectionMatrix ();  };</code></pre><ul><li>正交相机自适应</li></ul><pre><code class="js">    window.onresize=function(){      // 重置渲染器输出画布canvas尺寸      renderer.setSize(window.innerWidth,window.innerHeight);      // 重置相机投影的相关参数      k = window.innerWidth/window.innerHeight;//窗口宽高比      camera.left = -s*k;      camera.right = s*k;      camera.top = s;      camera.bottom = -s;      // 渲染器执行render方法的时候会读取相机对象的投影矩阵属性projectionMatrix      // 但是不会每渲染一帧，就通过相机的属性计算投影矩阵(节约计算资源)      // 如果相机的一些属性发生了变化，需要执行updateProjectionMatrix ()方法更新相机的投影矩阵      camera.updateProjectionMatrix ();    };</code></pre><h3 id="九、精灵模型Sprite"><a href="#九、精灵模型Sprite" class="headerlink" title="九、精灵模型Sprite"></a>九、精灵模型Sprite</h3><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><ul><li>应用：<ul><li>大数据可视化</li><li>下雨效果</li></ul></li><li>渲染效果:无论相机如何变化，始终平行于桌面矩形区域，等价于一个正面永远朝向屏幕的PlaneGeometry。</li><li>相比与网格模型等，精灵模型只需要材质属性，而不需要几何体参数。</li></ul><h5 id="精灵模型实现下雨"><a href="#精灵模型实现下雨" class="headerlink" title="精灵模型实现下雨"></a>精灵模型实现下雨</h5><pre><code class="js">    // 加载雨滴纹理贴图    var textureTree = new THREE.TextureLoader().load(&quot;rain.png&quot;);    // 创建一个组表示所有的雨滴    var group = new THREE.Group();    // 批量创建雨滴精灵模型    for (let i = 0; i &lt; 400; i++) {      var spriteMaterial = new THREE.SpriteMaterial({        map: textureTree, //设置精灵纹理贴图      });      // 创建精灵模型对象      var sprite = new THREE.Sprite(spriteMaterial);      group.add(sprite);      // 控制精灵大小,      sprite.scale.set(8, 10, 1); //// 只需要设置x、y两个分量就可以      var k1 = Math.random() - 0.5;      var k2 = Math.random() - 0.5;      // 设置精灵模型位置，在一个长方体空间中随机分布      sprite.position.set(200 * k1, 200 * Math.random(), 200 * k2)    }    scene.add(group);//雨滴群组插入场景中</code></pre><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a href="https://alligator.io/react/react-with-threejs" target="_blank" rel="noopener">https://alligator.io/react/react-with-threejs</a><br><a href="https://github.com/react-spring/react-three-fiber" target="_blank" rel="noopener">https://github.com/react-spring/react-three-fiber</a><br><a href="https://github.com/zrysmt/react-threejs-app" target="_blank" rel="noopener">https://github.com/zrysmt/react-threejs-app</a><br><a href="https://github.com/chenjsh36/ThreeJSForFun" target="_blank" rel="noopener">https://github.com/chenjsh36/ThreeJSForFun</a><br><a href="http://www.yanhuangxueyuan.com/Three.js/" target="_blank" rel="noopener">http://www.yanhuangxueyuan.com/Three.js/</a><br><a href="https://wow.techbrood.com/fiddle/new" target="_blank" rel="noopener">https://wow.techbrood.com/fiddle/new</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Three.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大脑Cache系列 -- Java快速梳理，方便随时load到大脑，减少低级bug（三）</title>
      <link href="/da-nao-cache/da-nao-cache-xi-lie-java-kuai-su-shu-li-fang-bian-sui-shi-load-dao-da-nao-jian-shao-di-ji-bug-san.html"/>
      <url>/da-nao-cache/da-nao-cache-xi-lie-java-kuai-su-shu-li-fang-bian-sui-shi-load-dao-da-nao-jian-shao-di-ji-bug-san.html</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><ul><li>Java程序常常会遇到一些蛋疼的bug，最后发现，都是在一些很基础的方面造成的。大量的时间花在调试代码找低级bug上是十分没有性价比的。所以，再系统梳理下Java，是十分必要的。</li><li>已经反复学习和使用Java多次了，但只要有段时间没用Java之后，每次使用前都想要重头再梳理一遍。本文章将更注重Java只是的系统性，而不是细节性。</li><li>本文是本人大脑的专属Cache，所以逻辑上可能只有我自己能够看懂，见谅。</li></ul></blockquote><h3 id="一、目录"><a href="#一、目录" class="headerlink" title="一、目录"></a>一、目录</h3><ul><li>Java泛型</li><li>Java集合</li><li>Java部署</li></ul><a id="more"></a><h3 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h3><ul><li>在不支持泛型之前，Java是通过继承实现对不同类型数据的支持，缺点是每次都需要进行格式转换</li><li>泛型：<strong>类型参数</strong></li></ul><pre><code class="java">// 泛型类public class Pair&lt;T, U&gt; { // 类型参数，支持多个  private T first;  private T second;  // 泛型方法，  public &lt;T&gt; T getFirst() { // 类型参数放在修饰符后边，返回类型前边     return first;  }}</code></pre><ul><li><strong>泛型方法可以定义在泛型类中，也可以定义在普通类中</strong></li></ul><pre><code class="java">public class Pair {  private int first;  public &lt;T&gt; T getFirst(){ // 泛型方法可以定义在普通类中    return first;  }}</code></pre><ul><li><strong>类型变量的限定</strong></li></ul><pre><code class="java">public class Pair &lt;T extends BindType1 &amp; BindType2&gt; // T必须是绑定类型的子类，对类型变量做了限定</code></pre><h5 id="泛型的虚拟机实现——类型擦除"><a href="#泛型的虚拟机实现——类型擦除" class="headerlink" title="泛型的虚拟机实现——类型擦除"></a>泛型的虚拟机实现——类型擦除</h5><ul><li><strong>虚拟机中并没有泛型类的对象，所有的对象都属于普通类</strong></li><li><strong>类型擦除</strong><ul><li><strong>原始类型</strong>：每一个泛型类型，都提供一个相应的原始类型。</li><li>原始类型名为泛型类删除类型参数</li><li>擦除类中的类型变量，替换为限定类型(第一个限定类型)，没有限定则为Object类型</li><li>比如Pair<t>类的原始类型为<pre><code class="java">public class Pair {private Object first;private Object getFirst(){return first;}}</code></pre></t></li></ul></li><li>程序调用泛型方法的时候，在虚拟机层面实际执行两条指令，多出来的一条为插入的类型转换指令，目的是回复擦除的类型。<ul><li>多出来的虚拟机指令是编译器添加的，在字节码中添加</li></ul></li></ul><h5 id="泛型的注意点"><a href="#泛型的注意点" class="headerlink" title="泛型的注意点"></a>泛型的注意点</h5><ul><li><strong>不能用基本类型作为类型参数</strong>，比如int,double，而要改用Integer，Double</li><li><strong>不对泛型类型对象做类型检查</strong><ul><li><strong>getClass返回的总是原始类型，而不是泛型类型</strong></li><li>同样的<strong>a instanceof Pair<string></string></strong>，编译错误</li></ul></li><li><strong>不能实例化创建参数化类型的数组</strong><ul><li><code>Pair&lt;String&gt; [] table = new Pair&lt;String&gt;[10]; // error</code><h5 id="泛型类型的继承规则"><a href="#泛型类型的继承规则" class="headerlink" title="泛型类型的继承规则"></a>泛型类型的继承规则</h5></li></ul></li><li><code>Pair&lt;Employee&gt;</code>和<code>Pair&lt;Manager&gt;</code>之间没有继承关系。</li></ul><h3 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h3><ul><li>传统的支持：Vector,Stack,HashTable,BitSet,Enumeration接口等</li></ul><h5 id="Java集合框架将集合的接口与实现分离"><a href="#Java集合框架将集合的接口与实现分离" class="headerlink" title="Java集合框架将集合的接口与实现分离"></a>Java集合框架将集合的接口与实现分离</h5><ul><li>队列接口Queue(interface)<ul><li>队尾添加元素，队头删除元素，先进先出，且能够获得队列元素数目</li><li>接口方法：add(E element),remove(),size()</li><li>集合实现这个接口就可以实现一个队列</li></ul></li><li>Collection集合接口<ul><li>Java集合类的<strong>基本接口</strong>，主要有两个重要的方法</li></ul></li></ul><pre><code class="java">public interface Collection&lt;E&gt; {  boolean add(E element); // 添加元素，不允许重复  Iterator&lt;E&gt; iterator(); // 返回实现了迭代器接口的对象，通过该迭代器对象可以依次访问集合中的元素  int size(); // 返回元素数目  boolean isEmpty();   boolean contains(Object obj); // 集合中是否存在该元素  boolean remove(Object obj); // 如果存在obj，则删除  void clear(); // 情况集合内容  Object[] toArray(); // 将集合转化为数组  ...}</code></pre><ul><li>迭代器Iterator<ul><li>for each循环需要集合实现iterator接口</li></ul></li></ul><pre><code class="java">public interface Iterator&lt;E&gt; {  // 类比编辑软件的光标、插入以及删除效果  E next(); // 越过当前元素，迭代到下一个（光标后移），并返回越过元素的内容  boolean hasNext(); // 判断是否能够越过当前元素  void remove(); // 删除光标之前的元素  default void forEachRemaining(Consumer&lt;? super E&gt; action); // Java8}// 使用,比如foreach的实际实现Collection&lt;String&gt; str = ...Iterator&lt;String&gt; iter = str.iterator();while(iter.hasNext()){  String element = iter.next();  dosomething...}// Java8中直接通过forEachRemaining和lamabda表达式实现itertor.forEachRemaining(element -&gt; {  do something with element})</code></pre><ul><li>元素的迭代顺序由具体的集合来决定</li><li>与C++中的迭代器不同（基于索引下标，不需要查找操作，直接通过索引i++），Java中的迭代器是<strong>查找操作与位置变更是紧密相连的，查找一个元素的唯一方法是调用next(),在执行查找操作的同时，迭代器已经就指向下一个元素了，返回上一个元素</strong></li><li><strong>next和remove方法的调用具有互相依赖性，在调用remove之前，如果没有调用next，将会抛出一个非法异常</strong></li><li><strong>删除两个相邻的元素的元素不能直接连续remove，必须调用next越到下一个元素</strong></li></ul><ul><li>Java集合框架中各种集合接口的关系</li></ul><pre><code class="java">- Iterable        可迭代接口  - Collection    集合类的基础类    - List        有序集合，能够有序访问和随机访问    - Set       - SortSet    - Queue      - Deque- Map             key value 映射  - SortedMap- Iterator  - ListIterator  针对于List的迭代器</code></pre><h5 id="Java中的具体集合类"><a href="#Java中的具体集合类" class="headerlink" title="Java中的具体集合类"></a>Java中的具体集合类</h5><ul><li>以Map结尾的都实现了Map接口，没有的都实现了Collection接口</li></ul><pre><code class="java">- AbstractCollection  - AbstractList        有序集合    - ArrayList         支持动态增长和缩减的索引序列    - LinkedList        链表类，支持高效插入和删除  - AbstractSet         数学中的集合，没有重复元素    - HashSet           没有重复元素的无序集合      - LinkedHashSet   可以记住元素插入顺序的集合    - TreeSet           有序集合    - EnumSet           包含枚举类型值的集合  - AbstractQueue    - PriorityQueue     优先级队列，高效删除最小元素的集合    - ArrayDequeue      循环数组实现的双端队列- AbstractMap           映射表  - HashMap             普通常用的键值对    - LinkedHashMap     在能记录键值对的添加次序  - TreeMap             键值有序排列  - EnumMap             键值为枚举类型的映射表  - WeakHashMap         一种当其值无用武之地的时候，可以被垃圾回收器回收的引射表  - IdentityHashMap     一种用===而不是queals比较键值的映射表</code></pre><h5 id="链表LinkedList"><a href="#链表LinkedList" class="headerlink" title="链表LinkedList"></a>链表LinkedList</h5><ul><li>数组Array和数组列表类对象ArrayList有个缺陷，在数组中间位置添加和删除的代价很大</li><li>Java的链表实际上是<strong>双向链表</strong>，有找到前向和后继的引用</li><li>链表实现了Collection接口，但Collection接口的add()方法只支持向链表最后添加元素，不支持链表的任意位置添加元素</li><li>在中间位置插入元素，通过ListIterator接口提供的方法实现。</li></ul><pre><code class="java">// 面向LinkedList链表的迭代器interface ListIterator extends Iterator&lt;E&gt; {  void add(E element); // 链表的插入方式，在当前迭代位置后加入一个元素  ...  E previous(); // 反向遍历链表，访问上一个元素  boolean hasPrevious(); // 与hasNext()类似}// 使用链表，并从中间加入元素List&lt;String&gt; staff = new LinkedList&lt;&gt;();staff.add(&quot;1&quot;);staff.add(&quot;3&quot;);staff.add(&quot;4&quot;);ListIterator&lt;String&gt; iter = staff.listIterator();iter.next(); // 跳过第一个元素，没有next的话，就是作为链表头iter.add(&quot;2&quot;); // 最终的结果，1234// n长度的链表，有n+1个插入位置|ABCA|BCAB|CABC|// 链表提供了一个set()方法来替换值，不用先删除再添加了ListIteartor&lt;String&gt; iter = new ListIteartor&lt;&gt;();String oldValue = iter.next(); // 得到第一个元素iter.set(newvalue); // 将第一个元素赋予新值</code></pre><ul><li>可以创建多个链表迭代器，比如用于并发，但是同时只能有一个迭代器用来修改链表集合，其他迭代器只能读取，多个迭代器同时修改会抛出异常。</li><li>链表作为一个List，也是支持有序访问和通过索引访问的的，但对于链表不推荐使用get(i)和set(i,value)</li></ul><h5 id="数组列表ArrayList"><a href="#数组列表ArrayList" class="headerlink" title="数组列表ArrayList"></a>数组列表ArrayList</h5><ul><li>有序列表，动态扩展和收缩</li><li>ArrayList不是同步的，是线程不安全的，适合在非并发的时候使用</li><li>Vector是同步的，线程安全的，但是同步操作上会耗费大量的时间，只在并发的时候使用</li></ul><h5 id="散列集HashSet"><a href="#散列集HashSet" class="headerlink" title="散列集HashSet"></a>散列集HashSet</h5><ul><li>不关注元素的顺序，只想要能够快速查找到元素，且无重复元素的集合Set</li><li>通过散列表来实现，散列表为每个对象计算一个散列码HashCode，对象的hashCode()方法在这个时候使用</li><li>装填因子，散列函数，桶，散列冲突等概念</li><li>对散列集的遍历顺序是随机的</li></ul><pre><code class="java">Set&lt;String&gt; words = new HashSet&lt;String&gt;();words.add(&quot;hello&quot;);Iterator&lt;String&gt; iter = words.iterator();iter.hasNext();String word = iter.next();</code></pre><h5 id="树集TreeSet"><a href="#树集TreeSet" class="headerlink" title="树集TreeSet"></a>树集TreeSet</h5><ul><li>有序集合，内部是树结构，按照树的顺序进行遍历（红黑树）</li><li>每次添加元素，都将元素添加到树中的正确位置。</li></ul><h5 id="队列Queue与双端队列ArrayDeque"><a href="#队列Queue与双端队列ArrayDeque" class="headerlink" title="队列Queue与双端队列ArrayDeque"></a>队列Queue与双端队列ArrayDeque</h5><ul><li>Queue</li></ul><pre><code class="java">  // 队尾添加  - boolean add(E element)   - boolean offer(E element)   // 对首删除并返回  - E remove()  - E poll()  // 只返回对首元素，不删除  - E element()  - E peek()</code></pre><ul><li>Deque</li></ul><pre><code class="java">void addFirst(E element)void addLast(E element)boolean offerFirst(E element)boolean offerLast(E element)E removeFirst()...</code></pre><h5 id="优先级队列PriorityQueue"><a href="#优先级队列PriorityQueue" class="headerlink" title="优先级队列PriorityQueue"></a>优先级队列PriorityQueue</h5><ul><li>支持任意顺序的插入，而每次remove，返回的都是队列中的最小值</li><li>内部通过堆来实现，是一个能够自我调整的二叉树，在对树进行add和remove操作中，能始终保证最小的元素移动到根</li><li>优先级队列用于任务调度</li></ul><pre><code class="java">// E 必须是支持比较的元素类型PriorityQueue&lt;E&gt; queue = new PriorityQueue&lt;&gt;();queue.add(element1); // 按照随机顺序加入，自动调整排序queue.add(element2);queue.add(element3);E min = queue.remove(); // 返回最小值</code></pre><h5 id="映射Map"><a href="#映射Map" class="headerlink" title="映射Map"></a>映射Map</h5><ul><li>HashSet是以对象副本来查找元素，不好用</li><li>映射通过键值对来查找元素</li><li>有<code>HashMap</code>和<code>TreeMap</code>两种<ul><li><code>HashMap</code>，通过对键进行散列，进而访问值</li><li><code>TreeMap</code>，利用键的顺序，对元素进行排序</li></ul></li><li>和集合一样，散列稍微快一些，如果不需要按照排列顺序访问键，推荐使用散列映射</li><li>Map的键使用的是字符串</li><li>添加键值对：<code>V put(K key,V value)</code><ul><li>重复用同一个key添加，会覆盖之前添加的值,返回之前的值</li><li>添加一个新的键，返回的值为null</li></ul></li><li>查找键值对:<code>V get(Object key)</code><ul><li>如果不存在该key，则返回null</li><li><code>V getOrDefault(Object key, V defaultValue)</code></li></ul></li><li>删除键值对：<code>remove(Object key)</code></li><li>判断是否有键：<code>boolean containsKey(Object key)</code></li><li>判断是否有值：<code>boolean containerValue(Object value)</code></li><li>遍历键值对：<code>hashMap.forEach((k,v)={do...})</code></li><li>三个视图View: keySet,valueSet,entrySet</li></ul><pre><code class="java">HashMap&lt;String,E&gt; hashMap = new HashMap&lt;String,E&gt;();hashMap.put(&quot;first&quot;,element1);hashMap.put(&quot;second&quot;,element2);hashMap.get(&quot;first&quot;);Set&lt;String&gt; keySet = hashMap.keySet();// {first,second}Set&lt;E&gt; valueSet = hashMap.valueSet();Set&lt;Map.Entry&lt;String,E&gt;&gt; entrySet = hashMap.entrySet();</code></pre><h5 id="弱散列集合WeakHashMap"><a href="#弱散列集合WeakHashMap" class="headerlink" title="弱散列集合WeakHashMap"></a>弱散列集合WeakHashMap</h5><ul><li>能够自动回收那些无用的键值对</li><li>如果有一个值，对应的键已经不再使用了，那么该键值对将无法从Map中删除</li><li>对于长期存活的Map，需要手动删除，或者直接使用WeakHashMap</li><li>内部实现中，WeakHashMap使用的弱引用(wek references)来保存键。<ul><li>弱引用对象将引用保存到另外一个对象中，在这里，就是散列键</li><li>如果某个对象，只有WeakReference引用，那么垃圾回收器可以回收它。</li></ul></li></ul><h5 id="链接散列集与映射LinkedHashSet与LinkedHashMap"><a href="#链接散列集与映射LinkedHashSet与LinkedHashMap" class="headerlink" title="链接散列集与映射LinkedHashSet与LinkedHashMap"></a>链接散列集与映射LinkedHashSet与LinkedHashMap</h5><ul><li>在实现HashSet与HashMap的基础上，还能够记录元素的添加顺序，即迭代遍历顺序</li><li>实现方式是在Hash表的基础上，再通过链表的方式将添加的元素顺序链接起来。</li></ul><h5 id="枚举集与映射EnumSet"><a href="#枚举集与映射EnumSet" class="headerlink" title="枚举集与映射EnumSet"></a>枚举集与映射EnumSet</h5><ul><li>如果key的类型为枚举，那么可以使用EnumSet</li><li>使用位序列进行了优化</li></ul><h5 id="表示散列映射IdentityHashMap"><a href="#表示散列映射IdentityHashMap" class="headerlink" title="表示散列映射IdentityHashMap"></a>表示散列映射IdentityHashMap</h5><ul><li>特殊用途：<strong>对象遍历算法</strong></li><li>hash计算不再通过对象的hashCode计算，而是通过System.identityHashCode计算，返回的是根据对象的内存地址计算的Hash值</li><li>所以不能用equal()来判断相等了，而是用==号来判断</li><li><strong>不同的键值对，即便内容一样，也被视为不一样的对象</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 大脑Cache </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[bug] Build React 项目中出现的Failed to minify the code from this file错误</title>
      <link href="/ji-zhu/bug-build-react-xiang-mu-zhong-chu-xian-de-failed-to-minify-the-code-from-this-file-cuo-wu.html"/>
      <url>/ji-zhu/bug-build-react-xiang-mu-zhong-chu-xian-de-failed-to-minify-the-code-from-this-file-cuo-wu.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>在React项目中运用到了flv.js以及three.js，通过yarn安装依赖，在开发环境下一切正常，但当执行yarn build打生产环境包时，出现了如下错误。</p></blockquote><pre><code class="js">Failed to minify the code from this file:./node_modules/flv.js/src/utils/logger.js:21</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>问题出在了库的引入上，原本代码为：</p><pre><code class="js">import flv.js from &#39;flv.js&#39;;</code></pre><p>更改为</p><pre><code class="js">import flv.js from &#39;flv.js/dist/flv.min.js&#39;;</code></pre><p>然后build就可以通过</p><a id="more"></a><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>用到的第三方软件包没有被正确编译成ES5<br>解决方法</p><ul><li>去项目站点提issue，让第三方软件包开发人员提供pre-compiled</li><li>自己编译，然后上传</li><li>将第三方库code直接复制到项目中使用（如果代码比较少的话）</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>解这个bug花了不小的时间，主要还是对React的打包过程和机制还不是很了解，有时间进一步了解一下。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大脑Cache系列 -- Java快速梳理，方便随时load到大脑，减少低级bug（二） </title>
      <link href="/da-nao-cache/da-nao-cache-xi-lie-java-kuai-su-shu-li-fang-bian-sui-shi-load-dao-da-nao-jian-shao-di-ji-bug-er.html"/>
      <url>/da-nao-cache/da-nao-cache-xi-lie-java-kuai-su-shu-li-fang-bian-sui-shi-load-dao-da-nao-jian-shao-di-ji-bug-er.html</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><ul><li>Java程序常常会遇到一些蛋疼的bug，最后发现，都是在一些很基础的方面造成的。大量的时间花在调试代码找低级bug上是十分没有性价比的。所以，再系统梳理下Java，是十分必要的。</li><li>已经反复学习和使用Java多次了，但只要有段时间没用Java之后，每次使用前都想要重头再梳理一遍。本文章将更注重Java只是的系统性，而不是细节性。</li><li>本文是本人大脑的专属Cache，所以逻辑上可能只有我自己能够看懂，见谅。</li></ul></blockquote><h3 id="一、目录"><a href="#一、目录" class="headerlink" title="一、目录"></a>一、目录</h3><ul><li>Java继承</li><li>Java反射</li><li>Java接口</li><li>Lambda表达式</li><li>Java异常</li></ul><a id="more"></a><h3 id="二、Java继承"><a href="#二、Java继承" class="headerlink" title="二、Java继承"></a>二、Java继承</h3><h5 id="Java与C-继承"><a href="#Java与C-继承" class="headerlink" title="Java与C++继承"></a>Java与C++继承</h5><ul><li>子类 extends 父类，而C++是：符号</li><li>Java只有公有继承，C++有公有继承和私有继承</li><li>Java只支持单继承，多继承通过接口实现</li><li>子类从父类继承所有的数据域和方法，但有一些不一定能够访问到。</li><li>此外，子类只能通过覆盖来修改，以及增加方法，但绝对无法删除父类的任何方法和数据域。</li></ul><h5 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h5><ul><li>覆盖：子类方法重写父类的方法，父类方法将会被覆盖，区别重载（本类方法之间）</li><li>覆盖时，子类和父类要严格一致（访问类型，返回值，方法名，参数列表）<ul><li>可以通过@Override来对子类的覆盖方法进行标记，来保障子类该方法成功覆盖了一个父类的方法，而不是定义了一个毫无相关的方法（没有匹配父类方法的时候，会编译报错）</li></ul></li><li>被覆盖的父类方法依然可以通过super方法调用。</li><li>super并不是像this那样是一个对象引用，<strong>super只是一个指示编译器调用父类方法的特殊关键字，所以不能将super赋值给另一个变量。</strong></li><li>super()调用父类的构造器</li></ul><h5 id="多态与动态绑定"><a href="#多态与动态绑定" class="headerlink" title="多态与动态绑定"></a>多态与动态绑定</h5><ul><li>多态：父类对象变量可以引用子类对象，且能够通过父类对象正确调用该对象的方法。</li><li>动态绑定：在运行时，能够自动选择调用哪个方法。</li><li>用途：有一组不同类型的对象数据，可以直接通过他们父类类型的数组来统一组织</li><li>不能将父类引用赋值给子类变量，但是可以将子类引用赋值给父类对象，且不需要强制类型转换。</li></ul><h5 id="方法调用的过程"><a href="#方法调用的过程" class="headerlink" title="方法调用的过程"></a>方法调用的过程</h5><ul><li><strong>对象在调用方法的时候，除了方法显式的参数之外，还有一个隐式参数，那便是对象本身，隐式参数不属于函数签名</strong></li><li>1.根据方法名，选出本类和父类中所有候选方法（父类中的方法需要是public的）</li><li>2.根据参数列表，进行重载解析，获得调用方法名字和参数类型，即函数签名（考虑子类覆盖父类）</li><li>3.如果该方法是private、static、final、或者构造器，那么编辑器就可以确定调用哪个方法了，这个称为静态绑定</li><li>4.可能存在多态的情况时，虚拟机会考虑到隐式参数对象的实际类型，选择调用对应类中的方法。依次实现运行时的动态绑定。</li></ul><h5 id="阻止继承-final类和方法"><a href="#阻止继承-final类和方法" class="headerlink" title="阻止继承 final类和方法"></a>阻止继承 final类和方法</h5><ul><li>final类，不允许被继承</li><li>final方法，子类不允许覆盖这个方法，final类中的所有方法都是final的。</li></ul><h5 id="对象强制类型转换"><a href="#对象强制类型转换" class="headerlink" title="对象强制类型转换"></a>对象强制类型转换</h5><ul><li>只能在继承链上进行类型转换</li><li>在将父类转成子类之前，最好使用instanceof检查是否转换错误</li></ul><pre><code class="java">if(child instanceof Manager){ // 不需要判null  manager = child;}</code></pre><ul><li>在一些参数传递的时候可能会使用</li></ul><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><ul><li>为了进一步提升父类的通用能力</li><li>抽象类：含有一个或者多个抽象方法的类，就是抽象类<ul><li>抽象类和抽象方法需要使用abstract来修饰</li><li>抽象类中是可以存在具体数据和具体方法的，可以存在一个抽象方法</li></ul></li><li>抽象类是可以不包含抽象方法的</li><li><strong>抽象类不能被实例化</strong>，必须通过子类实现所有的抽象方法才可以。</li><li>虽然抽象类不能实例化，但可以通过抽象类变量引用子类对象（这是正常的父类子类特点）。</li></ul><h5 id="受保护的访问"><a href="#受保护的访问" class="headerlink" title="受保护的访问"></a>受保护的访问</h5><ul><li>private：仅对本类可见</li><li>public：对所有类可见，无限制</li><li>protected：对本类和子类，以及本包类可见<ul><li><strong>如果想一个方法或者数据能够被子类访问，需要设置protected修饰符</strong></li></ul></li><li>默认情况：对本包类可见，<strong>对子类不可见</strong></li></ul><table><thead><tr><th align="center">修饰符</th><th align="center">本类</th><th align="center">本包</th><th align="center">子类</th><th align="center">其他包</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td></tr><tr><td align="center">private</td><td align="center">yes</td><td align="center">no</td><td align="center">no</td><td align="center">no</td></tr><tr><td align="center">protected</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">no</td></tr><tr><td align="center">default</td><td align="center">yes</td><td align="center">yes</td><td align="center"><strong>no</strong></td><td align="center">no</td></tr></tbody></table><h5 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h5><ul><li>所有类的超类</li><li>Java中只有基本类型不是对象，其他都是对象，都具有Object的方法和数据</li><li>equals():<ul><li><strong>在没重写的情况下，与==的效果是一致的，判断的是地址而不是实际的内容。</strong></li><li>String，Integer等类已经对equals()进行重写了。</li><li>我们在实现自己类的时候，需要自己来实现equals。（在实现自己实现equals后，还需要实现hashcode）（很套路，很多IDE是支持一键自动生成的）</li></ul></li><li>Class getClass()：获得该对象所属于的类<ul><li>class.getName获得类名</li></ul></li><li>hashcode(): 返回对象的散列值<ul><li>规定：<strong>两个对象，如果equals为true，那么hashcode一定要保证相同</strong>，即相等的对象有相同的hashcode。</li><li>默认的的hashcode都是参考了存储地址的，所以两个对象，默认的hashcode一定不一样，即便他们值可能是一样的。</li><li>因此<strong>当自己实现equals的时候，对应的也要实现hashcode，来保证重要规则</strong></li><li><strong>两个相等的对象必须要返回相同的hashcode码，但是相等的hashcode不一定是相等的变量</strong>，（hashcode的计算方式）</li><li>java对象的hashcode设计是为了配合基于散列的集合,添加元素的时候，通过hashcode和equals来快速判断对象是否已经存在（大大减少了equals次数，比纯equals循环要好多了）</li></ul></li><li>toString():将对象以字符串形式输出，常用于日志之类。Object中默认的为类名+Hash值</li></ul><h5 id="重写equals-Object-obj-方法（了解即可，可以IDE自动生成的，hh）"><a href="#重写equals-Object-obj-方法（了解即可，可以IDE自动生成的，hh）" class="headerlink" title="重写equals(Object obj)方法（了解即可，可以IDE自动生成的，hh）"></a>重写equals(Object obj)方法（了解即可，可以IDE自动生成的，hh）</h5><ul><li>1.引用的是同一个对象吗</li><li>2.obj为null吗？</li><li>3.两个是同一个类吗</li><li>4.obj强制转化成本类</li><li>5.一次判断各个数据域是否相等</li><li><strong>记得还要检查下hashcode是否要也要重写哦</strong></li></ul><h5 id="泛型数组-ArrayList"><a href="#泛型数组-ArrayList" class="headerlink" title="泛型数组 ArrayList"></a>泛型数组 ArrayList<type></type></h5><ul><li>普通数组无法再运行时更改数组的大小，可以使用泛型数组库，ArrayList</li></ul><pre><code class="java">ArrayList&lt;MyClass&gt; arrayList = new ArrayList();</code></pre><ul><li>Java老版本中的Vector也可以实现动态数组，但没ArrayList有效。</li><li>add(),向数组中添加一个元素，如果容量不够，会自动扩展</li><li>ArrayList不支持数组的[]访问方式</li><li>get(index),获取数组中index位置的元素</li><li>set(index,item),替换数组中的某个元素</li><li>size()，类似数组的length</li><li>arrayList.ensureCapacity(100),预分配100大小的数组</li><li>trimToSize(),当保证不再向数组中添加元素了，调用将释放多余分配的空间</li><li>arrayList.toArray(array),为了方便数组的访问，可以通过ArrayList构造，然后转换成普通数组并处理</li></ul><pre><code class="java">// 一种很好的实践ArrayList&lt;X&gt; list = new ArrayList&lt;&gt;();// add item to listX[] a = new X[list.size()];list.toArray(a);</code></pre><h5 id="对象包装器与自动装箱"><a href="#对象包装器与自动装箱" class="headerlink" title="对象包装器与自动装箱"></a>对象包装器与自动装箱</h5><ul><li>基本类型都有对应的类，Integer, Double,Boolean,Character，Void等</li><li>他们的超类为Number</li><li><strong>一旦包装器创建了，就不允许更改包装在其中的值了</strong></li><li>自动装箱和自动拆箱：能在基础类型和对应的类之间自动转换，这是由Java编译器实现的，添加了装箱拆箱语句</li><li><strong>Java的==号检测的是两个变量指向的地址是否相同</strong>，所以不同于基础类型，装箱后要用equals方法来判断值是否相等（他们重写了equals方法）</li><li>字符串Int转换：<code>int x = Integer.paseInt(&quot;1&quot;)</code>或者<code>Integer.valueOf(&quot;100&quot;)</code></li></ul><h5 id="参数可变的方法"><a href="#参数可变的方法" class="headerlink" title="参数可变的方法"></a>参数可变的方法</h5><ul><li>Java方法的参数数目可以是可变的</li><li>省略号<code>...</code>,可以出现在参数列表的最后，<strong>其实和数组的效果的类似的</strong></li></ul><pre><code class="java">printf(String fmt, Object...args);</code></pre><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><blockquote><p>Java反射机制能够在程序运行时，对于任意一个类，都能够知道这个类的所有属性和方法。对于任意一个对象，在有权限的情况下，能够调用方法和属性。即，动态获取信息以及动态调用对象方法的机制。</p><ul><li>反射，能够分析类能力，能够动态操纵Java代码</li><li>主要用户工具构造，在实际的应用中使用不多(也不建议在应用应用开发中过多使用)</li><li>Class类，Java运行时系统为每个类维护一个Class类</li><li>getClass(),Name.class</li></ul></blockquote><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul><li>抽象类是对类的抽象，而接口是对行为的抽象。</li><li><strong>接口中所有方法都自动是public，不需要额外加public修饰符（但在实现接口的类中，方法前必须加public）</strong></li><li>接口中<strong>不能含有实例域（接口没有实例）</strong>，但可以含有<strong>常量和静态常量</strong></li><li>对于方法，<strong>接口中不能提供实现</strong>（Java8后支持默认实现）</li><li>接口不是类，不能通过new被实例化成对象。</li><li>不存在接口实例化的对象，但是存在<strong>接口变量，且接口变量可以引用实现了它的类的对象</strong>。</li><li>接口支持继承另一个接口</li></ul><pre><code class="java">  public interface Comparable { // java.lang.Comparable    int compareTo(Object obj);  }  public Test implements Comparable {    public int compareTo(Object obj) { // 实现类时候，需要public      return Double.compare(salary,obj.salary); // 相减比较不适合浮点数    }  }</code></pre><ul><li><p>Java常用的内置接口</p><ul><li>Compalrable</li><li>Cloneable</li></ul></li><li><p>接口的意义在于统一服务的对外接口：Java是一种强类型语言，使用接口来解决类型的问题，编译器不需要再执行的时候进行类型检查（因为编译器认为只要这个类实现了这个接口，就一定能处理）</p></li><li><p>接口与继承（抽象类）</p><ul><li>Java不支持多继承，因为多继承会使语言更复杂</li><li>Java通过接口来实现多继承，一个类可以实现多个接口</li></ul></li><li><p>Java8之后，接口中可以存在静态方法并实现之了，目的是，这样就可以避免某些工具类必须要提供伴随类了。</p></li><li><p>默认方法：</p><ul><li>在我们实现接口的时候，很多时候只需要实现部分方法，默认方法为接口中的方法提供一个默认的实现。</li><li>用default修饰符，然后就可以在接口中简单实现这些方法了。</li></ul></li></ul><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><ul><li>将一个代码块像参数一样传递到另一个对象中（定时器，响应等），这个代码块会在未来的某个时刻会被调用。</li><li>对比通过传入对象来实现，Lambda表达式更优雅，使得Java支持函数式编程。</li><li><code>(参数列表) -&gt; {代码块}</code>，Lambda没有返回类型</li><li><strong>函数式接口</strong>：只含有一个抽象方法的接口，可以把Lambda赋值给一个函数式接口变量</li></ul><pre><code>@FunctionalInterface // 可选，用于编译检查是否只有一个抽象方法，类似Overridepublic interface FunctionalInterface&lt;T&gt;{    void accept(T t);}</code></pre><ul><li>Lambda表达式可以转化为对应的接口形式</li><li>Lambda表达式实际上是一个<strong>函数</strong>，传入之后会在某处会被执行，而不是一个对象。</li><li>所以不能将一个Lambda表达式赋值给一个Object变量，因为Object不是一个函数式接口</li><li>当我们想使用Lambda的时候，需要为其提供一个函数式接口</li><li>方法引用:<code>rrays.sort(strings,String::compareToIgnoreCase)</code>,其实也很好理解，因为Lambda是函数</li><li>Comparator函数式接口</li></ul><h5 id="Lambda表达式的变量作用域"><a href="#Lambda表达式的变量作用域" class="headerlink" title="Lambda表达式的变量作用域"></a>Lambda表达式的变量作用域</h5><ul><li>Lambda中的变量<ul><li>代码块中声明的，自己的</li><li>参数传入的</li><li><strong>自由变量</strong>，如何保证Lambda执行的时候，这些外部的变量还存在，没有被销毁？</li></ul></li><li>捕获，闭包：Lambda会存储自由变量的值，称为捕获。Lambda的代码块以及自由变量组成一个<strong>闭包</strong></li><li><strong>Lambda中只能引用值不会改变的变量/常量</strong></li><li><strong>Lambda的体和块有相同的作用域</strong>，所以块中不能定义与Lambda同一块中的已有变量。</li></ul><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><blockquote><p><a href="https://www.cnblogs.com/dolphin0520/p/3811445.html" target="_blank" rel="noopener">博客</a></p></blockquote><h5 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h5><ul><li>定义在另一个类中的类。</li><li><strong>并不是每个外部类的对象实例都有一个内部类实例</strong>，内部类实例对象是由外部类的方法来触发创建的。</li><li>特点：<ul><li><strong>内部类可以访问外部类的实例域</strong>，因为内部类具有外部类的引用。<ul><li>访问的外部实例域必须是final，这个和Lambda类似。</li><li>内部类对象中有一个隐式引用，它指向创建它的外部类对象（在内部类的构造函数中记录）。</li></ul></li><li>局部内部类对同一个包中的其他类不可见</li><li>创建内部类的前提是必须先创建外部类</li></ul></li></ul><h5 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h5><ul><li>定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。</li><li>和局部变量一样，不能有public、protected、private以及static修饰符的。</li></ul><h5 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h5><ul><li>只创建这个类的对象，但并没有为该类提供名字。</li><li>使用的最多，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。</li><li>一般只用在事件监听，接口回调等</li></ul><pre><code class="java">ActionListener listener = new AcitonListener() {  public void actionPerformed(ActionEvent event){    // do something  }}</code></pre><ul><li>类似的，在安卓SDK，Swing中用的很多，能够简化代码。但有了Lambda，还能够更简化。</li></ul><h5 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h5><ul><li>多一个static关键字，不需要依附外部类而存在。</li></ul><h5 id="对比Lambda表达式和匿名内部类"><a href="#对比Lambda表达式和匿名内部类" class="headerlink" title="对比Lambda表达式和匿名内部类"></a>对比Lambda表达式和匿名内部类</h5><ul><li>匿名内部类仍然是类，编译会生成.class文件，Lambda通过invokedynamic指令插入到主类对应的位置执行</li><li>对于匿名类，关键词 this 解读为匿名类，而对于 Lambda 表达式，关键词 this 解读为写就 Lambda 的外部类。</li><li>Java 编译器编译 Lambda 表达式并将他们转化为类里面的私有函数</li></ul><h3 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h3><h5 id="异常层次结构"><a href="#异常层次结构" class="headerlink" title="异常层次结构"></a>异常层次结构</h5><pre><code class="java">- Throwable  - Error    - Java运行时系统内部错误，以及资源耗尽错误    - 应用程序无法抛出，由系统自动抛出，必然导致程序终止  - Exception    - IOExpection      - 与程序无关，而与IO等有关的错误    - RuntimeException      - 由程序本身错误导致的异常（数组越界，null指针，错误类型转换）</code></pre><h5 id="受查与非受查异常"><a href="#受查与非受查异常" class="headerlink" title="受查与非受查异常"></a>受查与非受查异常</h5><ul><li><strong>非受查异常</strong>：Error以及RuntimeException，不需要显示声明，因为这些异常是可以努力避免的，处理它们比消除它们要好多了。</li><li><strong>受查异常</strong>：IOException，<strong>编译器会检查程序是否为这类异常提供了异常处理器</strong>，需要在程序中显示声明</li><li>声明受查异常<ul><li>一个方法不仅可以告诉编译器参数和返回值，还可以告诉编译器可能存在的异常</li><li>什么时候需要给方法声明受查异常<ul><li>1.方法的内部调用了某个抛出受查异常的方法</li><li>2.方法内部通过throw抛出了一个受查异常</li></ul></li></ul></li></ul><pre><code class="java">// 声明受查异常，是throws不是throw，因为可以是一个异常列表public void readFileFunc(File file) throws FileNotFoundException { }// 抛出一个异常throw new Exception();</code></pre><h5 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h5><ul><li>try-catch语句<ul><li>若try子句中没有异常则跳过catch子句，程序正常返回。</li><li>try子句中发生错误，终止try子句执行，<strong>程序无返回值</strong>。<ul><li>若catch子句能够捕获异常，则直接执行catch子句中的处理语句。</li><li>若catch子句无法捕获，则将该异常传递到上级调用方法来处理。</li></ul></li></ul></li><li>处理策略<ul><li>对于知道如何处理的受检异常，则直接捕获处理</li><li>对于不知道如何处理的受检异常，则传递到调用方进行处理</li><li>传递一个异常，需要在方法后添加<code>throws</code>关键字，告知调用方，提供需要的对应的异常处理器</li></ul></li><li>捕获多个异常</li></ul><pre><code class="java">try {  ...} catch(FileNotFoundException e){  ...} catch(IOException e){}</code></pre><ul><li>再此抛出异常链，<code>e.initCause(pre_e)</code></li></ul><h5 id="finally子句"><a href="#finally子句" class="headerlink" title="finally子句"></a>finally子句</h5><ul><li>无论是否抛出异常，都会执行</li><li>finally子句中也可能抛出异常，最好将try-catch和try-finally解耦</li><li>当try和finally中都有return的时候，finally中的return先执行，且最终的返回值会被finally覆盖。即，如果finally中有return，try中的return无意义</li></ul><pre><code class="java">try {  try{  // 内部try用于释放资源    ...  } finally {    io.close();  }} catch (IOExpection){  // error message}</code></pre><ul><li>带资源的try，自动解决资源释放处理问题</li></ul><pre><code class="java">try (Resource res = ...){  res...}// 执行完毕之后，会自动调用res.close()</code></pre><h5 id="使用异常须知"><a href="#使用异常须知" class="headerlink" title="使用异常须知"></a>使用异常须知</h5><ul><li>异常的开销比较大，不要使用异常来实现正常的业务。只在异常情况下使用异常</li><li>不要过于细分异常</li><li>不要压制异常，便于分析程序错误</li></ul><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><ul><li>断言机制允许在测试期间向代码中插入一些检查语句，代码发布之后，会自动移除</li><li>关键字，assert</li><li>一般用不到</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 大脑Cache </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大脑Cache系列--Java快速梳理，方便随时load到大脑，减少低级bug (一)</title>
      <link href="/da-nao-cache/da-nao-cache-xi-lie-java-kuai-su-shu-li-yi.html"/>
      <url>/da-nao-cache/da-nao-cache-xi-lie-java-kuai-su-shu-li-yi.html</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><ul><li>Java程序常常会遇到一些蛋疼的bug，最后发现，都是在一些很基础的方面造成的。大量的时间花在调试代码找低级bug上是十分没有性价比的。所以，再系统梳理下Java，是十分必要的。</li><li>已经反复学习和使用Java多次了，但只要有段时间没用Java之后，每次使用前都想要重头再梳理一遍。本文章将更注重Java知识的系统性，而不是细节性。</li><li>本文是本人大脑的专属Cache，所以逻辑上可能只有我自己能够看懂，见谅。</li></ul></blockquote><h3 id="一、目录"><a href="#一、目录" class="headerlink" title="一、目录"></a>一、目录</h3><ul><li>数据类型，字符串，数组</li><li>基础语句语法</li><li>类与对象</li></ul><a id="more"></a><h3 id="二、基础语法"><a href="#二、基础语法" class="headerlink" title="二、基础语法"></a>二、基础语法</h3><blockquote><ul><li>其实还是有很多基础知识，是自己平时写代码的时候没有注意到的，而这很容易导致一些低级bug，耗费大量的调试时间。</li></ul></blockquote><h5 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h5><ul><li>编译命令: javac Main.java，.java代码成为.class字节码。<ul><li>JIT编译器：编译与解释共存，JIT能够将热点代码直接编译成机器码，直接再JVM上执行。</li></ul></li><li>运行:java Main， JVM加载字节码，解释成机器码执行。</li><li>版本：java -version</li></ul><h5 id="8种基本类型"><a href="#8种基本类型" class="headerlink" title="8种基本类型"></a>8种基本类型</h5><ul><li>整数：byte(8)，short(16)，int(32)，long(64)</li><li>浮点：float(32)，double(64)</li><li>Unicode编码的char（16位，两个字节），相当于一个整型值（ASCII）</li><li>boolean（1）</li><li>因为JVM的存在，各数据类型的取值范围与具体的机器是无关的。</li><li>基础数据类型存储在栈中，不存储在堆上。</li></ul><h5 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h5><ul><li>java的整形均是有<strong>符号的</strong>，计算整型的数据范围</li><li>注意：在java中，为了保障移植性，<strong>整型的范围与实际的机器无关（C和C++中整型范围和目标平台是相关的）</strong>，JVM解决了不同机器整型之间的差别。</li><li>byte：1字节，一般很少用，用在底层文件处理，或者占用存储空间的大数组</li><li>short：2字节，和byte用处类似</li><li>int：4字节，最常用</li><li>long：8字节，比如需要表示星球上的居住人数，可以使用long，后缀可以加一个L或者l标识</li><li>更易读的整数方式：1_000_000, java编译器会自动去除这些下划线。</li></ul><h5 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h5><ul><li>float 4字节，有效位6-7位 </li><li>double 8字节，有效位15位</li><li><strong>默认为double，一般也很少用float（float的精度一般很难满足需求），除非在需要处理或者存储大量数据</strong></li><li>double后缀D或d，float后缀F或者f</li><li>特殊浮点数值（一般用不到）<ul><li>正无穷大：Double.POSITIVE_INFINITY</li><li>负无穷大: Double.NEGATIVE_INFINITY</li><li>非数字: Double.NaN, 判断用Double.isNaN(n),不能用 == 号</li></ul></li></ul><h5 id="字符类型char"><a href="#字符类型char" class="headerlink" title="字符类型char"></a>字符类型char</h5><ul><li>Java的char采用Unicode编码</li><li>占用两个字节</li><li>‘A’,”A”的区别：前者是字符类型常量，占两个字节，后者是字符串常量，存储在堆上。</li></ul><h5 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h5><ul><li><strong>和C++不一样，整型和boolean之间不能相互转换</strong></li></ul><h5 id="大数值-BigInteger-BigDecimal"><a href="#大数值-BigInteger-BigDecimal" class="headerlink" title="大数值 BigInteger BigDecimal"></a>大数值 BigInteger BigDecimal</h5><ul><li>不是一个java基础类型，而是一个java对象，可以表示任意精度的整型和浮点数。</li><li><strong>无法通过运算符计算，需要通过对应的方法进行运算。</strong></li><li>一般可以用在金额的计算。</li></ul><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><ul><li>声明-&gt;初始化-&gt;使用</li><li>Java变量在使用之前必须要进行初始化，否则会编译报错。</li></ul><h5 id="常量与类常量（静态常量）"><a href="#常量与类常量（静态常量）" class="headerlink" title="常量与类常量（静态常量）"></a>常量与类常量（静态常量）</h5><ul><li>final表示常量，只能被赋值一次，且声明的时候必须初始化</li><li>常量名推荐使用全大写,<code>final int NUMBER = 10;</code></li><li>static final，类常量，可以在类中多个方法中使用</li><li>注意：与C++不同，常量不是通过const声明的，Java中const是保留字，但没有实际作用。</li></ul><h5 id="常用的Math静态方法"><a href="#常用的Math静态方法" class="headerlink" title="常用的Math静态方法"></a>常用的Math静态方法</h5><ul><li>平方根：<code>double result = Math.sqrt(double x);</code></li><li>幂运算：<code>double result = Math.pow(x,a);</code></li><li>四舍五入：<code>long n = Math.round(double x);</code></li><li>随机数: <code>Math.random()</code>,返回0-1之间的随机浮点数，比如要取0 - n-1之间的随机数，<code>int result = (int)(Math.random() * n)</code>.</li></ul><h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><ul><li>强制类型转换会导致结果被截断成一个完全不同的值，比如(byte)300 的值为 44</li><li>不要将boolean与任何类型之间做类型转换。</li></ul><h5 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h5><ul><li>自定义枚举类型</li></ul><pre><code>  enum Size {    SMALL, LARGE, EXTRA_LARGE  };</code></pre><ul><li>使用</li></ul><pre><code>  Size size = Size.SMALL;</code></pre><h5 id="字符串String类型"><a href="#字符串String类型" class="headerlink" title="字符串String类型"></a>字符串String类型</h5><ul><li>不是Java的基础类型，而是一个预定义类。</li><li><strong>和C++不同，Java中的String不是字符数组，而是一个对象，可以理解为char*指针</strong></li><li>Java 的字符串是<strong>不可变的</strong>，对字符串的修改，实际上是创建了一个新的String对象，目的是为了复用和共享存在堆上的字符串**<ul><li>源码中字符串内容有final修饰。</li></ul></li><li>对字符串修改的需求没有对字符串进行比较的需求大。<ul><li>比较：equals</li><li>修改：StringBuffer，StringBuilder</li></ul></li><li>字符串比较：要使用equal(str)方法，而不能使用 == 来判断<ul><li>因Java没有像C++那样，重载了==运算符。</li><li>==实际判断的是两个字符串变量是否引用的是同一个存储位置，而不是内容。</li><li>所以 == 判断的结果是未知的，常常会导致隐藏bug。</li></ul></li><li>字符串判空,<strong>区分空串和Null串</strong><ul><li>if(str != null &amp;&amp; str.length()!=0)</li></ul></li><li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</li><li>码点与代码单元<ul><li><strong>最好避免直接操作char，这太底层了</strong></li><li>str.length()返回的是代码单元个数</li><li>str.codePointCount(0,str.length()),统计的是码点数量</li><li>str.charAt(n),获取n位置的代码单元</li><li>关于代码单元与码点：</li></ul></li></ul><h5 id="常用的String-API"><a href="#常用的String-API" class="headerlink" title="常用的String API"></a>常用的String API</h5><pre><code class="java">char charAt(int index)boolean equals(Object obj)boolean equalsIgnoreCase(String str)boolean startsWith(String prefix)，判断是否是以prefix为前缀boolean endsWith(String suffix)，判断是否以suffix为后缀boolean indexof(String str), 找到字串str第一次出现的位置，没有则返回-1int length(),字符串长度int codePointCount(int startIndex, int endIndex),统计代码点数目String substring(int begin , int end);String toLowerCase(), toUpperCase()Stirng trim(), 删除字符串开始和结尾的空格String join(&#39;divider&#39;,CharSequence...emements)</code></pre><h5 id="StringBuilder，StringBuffer字符串构造"><a href="#StringBuilder，StringBuffer字符串构造" class="headerlink" title="StringBuilder，StringBuffer字符串构造"></a>StringBuilder，StringBuffer字符串构造</h5><ul><li>在有构造字符串或者修改字符串的情况下，不适合使用String，因为是不可变的。</li><li>推荐使用StringBuilder（单线程）或者StringBuffer（多线程）。</li><li>使用方式</li></ul><pre><code>String builder = new StringBuilder(); // 创建一个构造器builder.append(&quot;hello&quot;);builder.append(&quot;world&quot;); // 追加字符或者字符串String str = builder.toString(); // 构造String对象// 其他apibuilder.setCharAt(index,char)builder.delete(start,end)builder.insert(offset,string)</code></pre><ul><li>StringBuilder的前身是StringBuffer，但是StringBuffer的效率要低一些，因为它是线程安全的，允许多线程操作</li><li>而StringBuilder是非线程安全的，一般在单线程的应用。而在并发中使用StringBuffer</li><li>他们的API是一样的</li></ul><h5 id="读取输入"><a href="#读取输入" class="headerlink" title="读取输入"></a>读取输入</h5><ul><li>从控制台读取基础数据类型</li></ul><pre><code>  Scanner scan = new Scanner(System.in); //创建scanner，并与标准输入关联,System.in的类型为InputStream  scan.nextLine();  scan.next();  scan.nextInt();  scan.nextDouble();  scan.hasNext();  scan.hasNextInt();</code></pre><ul><li>从控制台读取密码</li></ul><pre><code>// java se 6 提供了Console类实现读取密码Console console = System.console();Stirng userName = console.readLine(&quot;UserName:&quot;);char [] psd = console.readPassword(&quot;Password:&quot;);</code></pre><h5 id="字符文件输入输出"><a href="#字符文件输入输出" class="headerlink" title="字符文件输入输出"></a>字符文件输入输出</h5><ul><li>读取字符文件</li></ul><pre><code>Scanner scan = new Scanner(Path.get(&quot;pathstring&quot;),&quot;UTF-8&quot;); // 路径是相对于Java虚拟机启动路径的相对位置scan.readLine()....等一系列方法</code></pre><ul><li>写字符文件</li></ul><pre><code>PrintWriter out = new PrintWriter(&quot;filename.txt&quot;,&quot;UTF-8&quot;);out.println(&quot;hhh&quot;);</code></pre><ul><li>对于处理文件的Scanner以及PrintWriter，需要在方法中处理异常</li></ul><h5 id="Java的块作用域"><a href="#Java的块作用域" class="headerlink" title="Java的块作用域"></a>Java的块作用域</h5><ul><li><strong>和C++不一样，Java不允许在嵌套块中重复定义一个变量，会编译错误</strong></li></ul><pre><code>{  int n;  {    int n; // 这种写法在java中是编译不过的  }}</code></pre><h5 id="switch-case-break"><a href="#switch-case-break" class="headerlink" title="switch case break"></a>switch case break</h5><ul><li>虽然很简单，但周围很多人都会用错</li><li>break的意思是，本case如果命中了，在执行结束之后，中断之后的case检查，直接返回。</li><li>多个case可以公用同一个处理函数</li><li>case标签的类型可以是char，4种整型，枚举常量，以及字符串常量（Java7开始支持）</li></ul><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><ul><li><p>数组声明：int [] array;</p></li><li><p>数组初始化： array = new int [100];</p><ul><li>需要指定数组初始大小，可以是整型n变量，数组创建之后大小无法更改。（如果需要，使用数组列表）</li><li>整型数组所有元素初始化为0，boolean初始化为false，对象类型初始化为null</li></ul></li><li><p>数组元素个数：array.length</p></li><li><p>数组for循环：for(int item : array)</p></li><li><p>数组拷贝</p><ul><li>浅拷贝：直接将一个数据变量的值赋值给另一个数组变量，两个数组变量引用的是堆中的同一个数组，对一个的修改会影响到另一个</li><li>深拷贝：在原来的基础上，新创建一个一模一样的数组，或者更长的数组。Array提供了copyOf方法<pre><code class="java">int [] newArray = Array.copyOf(array,array.length+10); // 拷贝array数组，长度加10</code></pre></li></ul></li><li><p>Java中的数据是在堆上创建的，相当于C++中的<code>int * a = new int[30];</code>,而不是<code>int a[10];</code>,这是在栈中的数组。</p></li><li><p>多维数组：数组的元素还是数组而已，且Java还支持不规则的数组（行列不一定要求是整齐的），C++是不支持的</p></li></ul><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><ul><li>类与对象的关系：模板，实例</li><li>类之间的三种关系</li><li>对象与对象变量（对象引用）<ul><li>对象实例存储在堆上，对象引用存储在栈中。</li><li>一个对象实例可以被多个变量引用，一个变量可以引用0或1个对象实例。</li></ul></li><li>预定义类（String，Date，LocalDate）与自定义类</li><li>Java多源文件的使用：Java编译器内置了类似UNIX的make功能，在编译的时候，能够自动查找需要依赖的其他类，有class文件就直接使用，没有则查找java文件并编译。</li><li>Java中，所有的方法都必须包含在类中</li><li>private私有域，只有属于同一个类的对象（本身，其他同类对象）才可以访问。</li><li>final常量、final方法：</li><li>静态变量、静态常量、静态方法</li><li>静态方法中不能访问非静态实例域，但可以访问静态域。</li><li>main()方法是一个静态方法，它不对任何对象进行操作，负责在程序启动的时候创建对象。</li><li>每个类都可以实现一个main方法，用来进行单元测试，在执行完整Application时候，每个单元中的main并不会执行。</li></ul><h5 id="对象构造与构造函数"><a href="#对象构造与构造函数" class="headerlink" title="对象构造与构造函数"></a>对象构造与构造函数</h5><ul><li>构造函数：Java的对象都是在堆上构造的，通过new操作符在堆上创建新对象。构造函数在new对象的时候被调用。<ul><li>与C++中对象的构造做区分，C++中支持在栈和堆上创建对象，Java对象与后者类似。</li></ul></li><li>构造函数不允许被重写Override</li><li>推荐在自定义多参数构造函数的时候，提供一个空参数的构造函数<ul><li>因为若子类在构造函数中没有通过super方式调用父类构造函数，Java会默认调用父类的无参数构造函数。若父类没有空构造函数，则会编译错误。</li></ul></li></ul><h5 id="对象域的初始化"><a href="#对象域的初始化" class="headerlink" title="对象域的初始化"></a>对象域的初始化</h5><ul><li>三种域初始化方式：在构造器中初始化，声明中初始化，在初始化块</li><li>在用户没给构造函数的时候，系统会自动提供一个无参构造函数，一旦用户提供了，系统就不再提供无参构造函数。</li><li>对象中的域，默认被初始化为0，false，以及null</li><li>域的初始化也可以直接在声明时进行，好习惯是在声明变量域的时候，就给个安全的初始值。（C++中是不允许的，只能通过构造函数初始化域）</li><li>初始化块：一个或多个代码块，只要构造类对象，这些初始化块就一定会执行，一般用于初始化比较复杂的情况。</li></ul><pre><code class="java">class Employee{  private int id;  // 初始化块  static  {    Random generator = new Random();     id = generator.nextInt(1000); // 生成0-999的随机数    System.out.println(&quot;hello&quot;); //也可以执行非初始化语句的  }}</code></pre><ul><li>具体的域初始化步骤<ul><li>1.所有数据域被初始化为0，false、null</li><li>2.按照类中各个数据域声明出现的前后顺序，执行各自的初始化语句以及初始化块。</li><li>3.执行构造器内容</li></ul></li></ul><h5 id="对象析构-finalize方法"><a href="#对象析构-finalize方法" class="headerlink" title="对象析构 finalize方法"></a>对象析构 finalize方法</h5><ul><li>Java有自动的垃圾回收器，所以不像C++，没有显式的析构器。</li><li>可以为类添加一个finalize方法，该方法在对象被清楚之前调用。</li><li><strong>实际应用中，避免在finalize中去释放资源，因为finalize什么时候被执行是无法确定的</strong></li><li>对于一些资源的使用，要提供一个close方法，在使用完毕后调用。</li><li>可以通过Runtime.addShutdownHook 方法来添加关闭钩子的方式更好的实现。</li></ul><h5 id="方法参数传递"><a href="#方法参数传递" class="headerlink" title="方法参数传递"></a>方法参数传递</h5><ul><li>Java的参数传递是<strong>传值调用</strong>的，方法得到的是参数的拷贝，且<strong>方法内无法修改传递进来的参数</strong>。</li><li>对于基本数据类型，直接传入的是数据拷贝，而对于对象，传入的是对象引用的拷贝（<strong>容易理解为传引用调用，但实际是通过传值调用实现的，只是这里的值是对象引用</strong>）。<ul><li>对于基本数据类型参数，参数传递不会改变参数变量的值。</li><li>对于对象引用参数，方法内可以通过对象应用去修改对象内容。</li><li>对于对象引用参数，无法将对象引用参数指向另一个新对象。</li></ul></li></ul><h5 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h5><ul><li>重载：overloading，多个方法，有相同的名字，但有不同的参数列表。</li><li>重载解析：编译器负责根据参数列表，匹配正确的函数。</li><li>函数签名：函数名+参数列表，<strong>注意，返回类型不属于函数签名，不能通过不同的返回类型来重载</strong></li></ul><h5 id="包-package"><a href="#包-package" class="headerlink" title="包 package"></a>包 package</h5><ul><li>通过包来组织类，文件目录方式，避免重名</li><li>import导入类、静态导入</li><li>将类放入包中：<ul><li>1.类源代码开头添加 package path; （没有该行，则该类属于默认包）</li><li>2.将类源文件放在package对应的问价夹中</li></ul></li><li><strong>编译器在编译文件的时候是不关注目录结构的，但定位一个类的时候，通过包名和类名来定位。所以，必须将类源代码放在package对应的文件夹下，否则虚拟机找不到类</strong></li><li>包作用域：不添加public和private时，默认的作用域。同一个包中都可以访问。</li></ul><h5 id="类路径"><a href="#类路径" class="headerlink" title="类路径"></a>类路径</h5><ul><li>从三个地方加载类<ul><li>1.JRE中的JAR文件</li><li>2.第三方JAR文件</li><li>3.用户源程序目录</li></ul></li><li>通过<code>java -classpath</code>或者设置<code>CLASSPATH</code>环境变量来设置类路径。</li></ul><h5 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h5><ul><li>javadoc，由源文件生成html</li><li>类注释</li></ul><pre><code class="java">/**  类注释*/class hhh{}</code></pre><ul><li>方法注释</li></ul><pre><code class="java">/*** desc hh* @param id* @return void* @throws*/private void hh(int id){}</code></pre><ul><li>域注释</li></ul><pre><code class="java">/*** desc*/int id;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>欲知后事如何，且听下回，太长了，逃。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 大脑Cache </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>update-alternatives 让多个版本库共存</title>
      <link href="/ji-zhu/update-alternatives-rang-duo-ge-ban-ben-ku-gong-cun.html"/>
      <url>/ji-zhu/update-alternatives-rang-duo-ge-ban-ben-ku-gong-cun.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录在解决Ubuntu系统python2.7与python3.4共存的问题，使用update-alternatives在两个版本之间进行切换</p></blockquote><h3 id="update-alternatives"><a href="#update-alternatives" class="headerlink" title="update-alternatives"></a>update-alternatives</h3><h5 id="检查update-alternatives是否已经检测到两个版本的python"><a href="#检查update-alternatives是否已经检测到两个版本的python" class="headerlink" title="检查update-alternatives是否已经检测到两个版本的python"></a>检查update-alternatives是否已经检测到两个版本的python</h5><pre><code>update-alternatives --list python</code></pre><p>如果出现以下错误，则说明未添加</p><pre><code>update-alternatives: error: no alternatives for python</code></pre><a id="more"></a><h5 id="更新替代列表，将两个版本的python放入其中"><a href="#更新替代列表，将两个版本的python放入其中" class="headerlink" title="更新替代列表，将两个版本的python放入其中"></a>更新替代列表，将两个版本的python放入其中</h5><p>update-alternatives –install [link] [name] [path] [priority]</p><pre><code>update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1update-alternatives --install /usr/bin/python python /usr/bin/python3.4 2</code></pre><h5 id="再此检查是否添加成功"><a href="#再此检查是否添加成功" class="headerlink" title="再此检查是否添加成功"></a>再此检查是否添加成功</h5><pre><code>update-alternatives --list python</code></pre><p>结果</p><pre><code>/usr/bin/python2.7/usr/bin/python3.4</code></pre><h5 id="切换配置"><a href="#切换配置" class="headerlink" title="切换配置"></a>切换配置</h5><pre><code>update-alternatives --config python</code></pre><p>结果</p><pre><code>  Selection    Path                Priority   Status------------------------------------------------------------* 0            /usr/bin/python3.4   2         auto mode  1            /usr/bin/python2.7   1         manual mode  2            /usr/bin/python3.4   2         manual modePress enter to keep the current choice[*], or type selection number:</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>使用update-alternatives工具之后，在不同版本之间穿梭将变得十分方便，是个值得掌握的工具</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx日常使用中的配置积累</title>
      <link href="/ji-zhu/nginx-pei-zhi-yun-xu-kua-yu.html"/>
      <url>/ji-zhu/nginx-pei-zhi-yun-xu-kua-yu.html</url>
      
        <content type="html"><![CDATA[<h3 id="配置https"><a href="#配置https" class="headerlink" title="配置https"></a>配置https</h3><pre><code>server {  listen        443;  server_name   zwboy.cn;  ssl           on;  ssl_certificate_key   ./cert/zwboy.cn.prikey.key  ssl_certificate       ./cert/zwboy.cn.pem;  location / {    proxy_pass http://localhost:8080;    proxy_set_header HOST $host;  }}# http跳转到httpsserver {  listen 80 default_server;  listen [::]:80 default_server; # ip访问  server_name zwboy.cn;  return 302 https://$server_name$request_uri; # 302跳转到https}</code></pre><a id="more"></a><h3 id="配置支持http2"><a href="#配置支持http2" class="headerlink" title="配置支持http2"></a>配置支持http2</h3><pre><code>server {  listen       443 http2; # 加上一个http2就可以了  server_name  zwboy.cn;  http2_push_preload  on; # 开启支持http2的推送特性  ssl           on;  ssl_certificate_key   ./cert/zwboy.cn.prikey.key  ssl_certificate       ./cert/zwboy.cn.pem;  location / {    proxy_pass http://127.0.0.1:8888;    proxy_set_header Host $host;  }}</code></pre><h3 id="配置nginx缓存"><a href="#配置nginx缓存" class="headerlink" title="配置nginx缓存"></a>配置nginx缓存</h3><pre><code>proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m;server {  listen       80;  # listen       [::]:80 default_server;  server_name  zwboy.cn;  # return 302 https://$server_name$request_uri;  location / {    proxy_cache my_cache;    proxy_pass http://127.0.0.1:8888;    proxy_set_header Host $host;  }}</code></pre><h3 id="配置跨域"><a href="#配置跨域" class="headerlink" title="配置跨域"></a>配置跨域</h3><pre><code>server{    location / {        add_header Access-Control-Allow-Origin *;      add_header Access-Control-Allow-Methods &#39;GET, POST, OPTIONS&#39;;      add_header Access-Control-Allow-Headers &#39;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization&#39;;      if ($request_method = &#39;OPTIONS&#39;) {          return 204;      }  }}</code></pre><h3 id="配置多个host的代理"><a href="#配置多个host的代理" class="headerlink" title="配置多个host的代理"></a>配置多个host的代理</h3><pre><code>server {        listen 80;  # 设置Nginx对外监听80端口        server_name *.domain.cn;  # 绑定到该服务器的域名        if ( $http_host ~* &quot;^(.*?)\.domain\.cn&quot; ) {  # 对http_host进行正则匹配，解析domain                set $domain $1;        }        location / {                proxy_set_header        X-Real-IP       $remote_addr;                proxy_set_header        Host            $http_host;                # 分别处理各个domain                if ( $domain ~* &quot;www&quot; ) {                        proxy_pass http://localhost:82;  # 通过proxy_pass 进行代理转发                }                if ( $domain ~* &quot;gitlab&quot; ) {                        proxy_pass http://localhost:82;                }                if ( $domain ~* &quot;jenkins&quot; ) {                        proxy_pass http://localhost:9090;                }        }}</code></pre><h3 id="部署React前端单页应用"><a href="#部署React前端单页应用" class="headerlink" title="部署React前端单页应用"></a>部署React前端单页应用</h3><pre><code>server {    listen 8083;    root /home/name/..../build; # 前端build完成之后的静态资源路径    index index.html index.htm;    location / {        try_file $uri $uri/ /index.html;  # url 切换时始终返回index.html    }    # 其他配置    # 图片样式缓存1年    location ~* /app.*\.(js|css|png|jpg)$ {       access_log off;        expires    365d;    }    # html/xml/json 文件不缓存    location ~* /app.*\.(?:manifest|appcache|html?|xml|json)$ {        expires    -1;    }}</code></pre><h3 id="server-name"><a href="#server-name" class="headerlink" title="server_name"></a>server_name</h3><pre><code>server{  server_name primary.zwboy.cn blog.zwboy.cn;  server_name_in_redirect off;  return 302 /redirect;}</code></pre><h3 id="nginx-http模块的11个阶段"><a href="#nginx-http模块的11个阶段" class="headerlink" title="nginx http模块的11个阶段"></a>nginx http模块的11个阶段</h3><blockquote><p>简化的阶段：1.读取request头，2.检查配置块，3.流量控制（是否超出连接限制，速率控制），4.鉴权（是否盗链），5.生成内容（5.1作为代理服务器，去上有请求数据，5.2，内部生成数据），6.Response 过滤（压缩，SSL等），7.日志处理</p></blockquote><ul><li>实际是按照以下11个阶段顺序进行的</li></ul><h5 id="POST-READ"><a href="#POST-READ" class="headerlink" title="POST_READ"></a>POST_READ</h5><ul><li>读取request headers之后</li><li>realip，拿到用户的真实ip，可以用于限流等<h5 id="SERVER-REWRITE"><a href="#SERVER-REWRITE" class="headerlink" title="SERVER_REWRITE"></a>SERVER_REWRITE</h5></li><li>rewite模块<h5 id="FIND-CONFIG"><a href="#FIND-CONFIG" class="headerlink" title="FIND_CONFIG"></a>FIND_CONFIG</h5></li><li>nginx模块本身<h5 id="REWRITE"><a href="#REWRITE" class="headerlink" title="REWRITE"></a>REWRITE</h5><h5 id="POST-REWRITE"><a href="#POST-REWRITE" class="headerlink" title="POST_REWRITE"></a>POST_REWRITE</h5></li><li>rewrite之后的阶段<h5 id="PREACCESS"><a href="#PREACCESS" class="headerlink" title="PREACCESS"></a>PREACCESS</h5></li><li>确认访问权限前的阶段</li><li>limt_conn，并发连接限制</li><li>limt_req，每秒请求数限制<h5 id="ACCESS"><a href="#ACCESS" class="headerlink" title="ACCESS"></a>ACCESS</h5></li><li>判断能不能访问</li><li>auth_basic，用户名，密码</li><li>access，根据ip</li><li>auth_request，根据第三方服义判断<h5 id="POST-ACCESS"><a href="#POST-ACCESS" class="headerlink" title="POST_ACCESS"></a>POST_ACCESS</h5></li><li>访问之后阶段<h5 id="PRECONTENT"><a href="#PRECONTENT" class="headerlink" title="PRECONTENT"></a>PRECONTENT</h5></li><li>连接前阶段</li><li>try_files<h5 id="CONTENT"><a href="#CONTENT" class="headerlink" title="CONTENT"></a>CONTENT</h5></li><li>index</li><li>autoindex</li><li>concat<h5 id="LOG"><a href="#LOG" class="headerlink" title="LOG"></a>LOG</h5></li><li>access_log</li></ul><h3 id="realip"><a href="#realip" class="headerlink" title="realip"></a>realip</h3><pre><code class="bash">server{  server_name domain.cn;  set_real_ip_from 111.111.112.1;  real_ip_recursive on;  real_ip_header X-Forwardwd-For;  # realip可以来自Http的头，X-Forwardwd-For和Real-IP  location / {    return 200 &quot;Client real ip: $remote_addr\n&quot;;  }}</code></pre><h3 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a>rewrite</h3>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能服务器：实现简单的TCP/UDP server，以及对应的Client</title>
      <link href="/ji-zhu/gao-xing-neng-fu-wu-qi-shi-xian-jian-dan-de-tcp-udp-server-yi-ji-dui-ying-de-client.html"/>
      <url>/ji-zhu/gao-xing-neng-fu-wu-qi-shi-xian-jian-dan-de-tcp-udp-server-yi-ji-dui-ying-de-client.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>有兴趣搞一搞高性能流媒体服务器，这些得了解，学习过程中记录一下，方便未来回顾。</p></blockquote><h3 id="一、实现一个TCP-Server"><a href="#一、实现一个TCP-Server" class="headerlink" title="一、实现一个TCP Server"></a>一、实现一个TCP Server</h3><h5 id="Server端步骤"><a href="#Server端步骤" class="headerlink" title="Server端步骤"></a>Server端步骤</h5><ul><li>socker():创建socket，指定使用TCP协议</li><li>bind():将socket与地址和端口进行绑定</li><li>listen():侦听端口</li><li>accept():创建新的socket</li><li>recv():使用recv接收数据</li><li>send():使用send发送数据</li><li>close():使用close关闭连接</li></ul><a id="more"></a><h5 id="TCP常见套接字选项"><a href="#TCP常见套接字选项" class="headerlink" title="TCP常见套接字选项"></a>TCP常见套接字选项</h5><ul><li>SO_REUSEADDR: 地址重用<ul><li>之前程序结束，端口处于WAIT_TIME状态下，新启动的程序仍然可以启动</li></ul></li><li>SO——RCVBUF：设置接收缓冲区大小</li><li>SO_SNDBUF: 设置发送缓冲区大小</li></ul><h5 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h5><pre><code class="c++">#include &lt;iostream&gt;#include &lt;sys/socket.h&gt; // for socket(),setsockopt#include &lt;netinet/in.h&gt; // for struct sockaddr_in#include &lt;stdlib.h&gt;     // for exit()#include &lt;unistd.h&gt;     // for close()#include &lt;string.h&gt;     // for bzero()#define PORT 8881#define MESSAGE_LEN 1024int main(int argc, char *argv[]){    int ret = -1;    int on = 1;    int socket_fd, accept_fd;    int backlog = 10; //缓冲长度，与并发量相关    struct sockaddr_in localaddr, remoteaddr;    char in_buff[MESSAGE_LEN] = {        0,    }; // 接收缓冲区    socket_fd = socket(PF_INET, SOCK_STREAM, 0);    if (socket_fd == -1)    {        std::cout &lt;&lt; &quot;failed to create socket!&quot; &lt;&lt; std::endl;        exit(-1);    }    ret = setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR,                     &amp;on, sizeof(on));    if (ret == -1)    {        std::cout &lt;&lt; &quot;failed to set socket options!&quot; &lt;&lt; std::endl;    }    localaddr.sin_family = AF_INET;    localaddr.sin_port = PORT;    localaddr.sin_addr.s_addr = INADDR_ANY;    bzero(&amp;(localaddr.sin_zero), 8);    ret = bind(socket_fd, (struct sockaddr *)&amp;localaddr, sizeof(struct sockaddr));    if (ret == -1)    {        std::cout &lt;&lt; &quot;failed to bind &quot; &lt;&lt; std::endl;        exit(-1);    }    ret = listen(socket_fd, backlog);    if (ret == -1)    {        std::cout &lt;&lt; &quot;failed to listen &quot; &lt;&lt; std::endl;        exit(-1);    }    for (;;)    {        socklen_t addr_len = sizeof(struct sockaddr);        accept_fd = accept(socket_fd,                           (struct sockaddr *)&amp;remoteaddr,                           &amp;addr_len);        int pid = fork();        for (;;)        {            ret = recv(accept_fd, (void *)in_buff, MESSAGE_LEN, 0);            if (ret == 0) // 说明没数据了            {                std::cout &lt;&lt; &quot;recv finish，end！ &quot; &lt;&lt; std::endl;                break;            }            std::cout &lt;&lt; &quot;receive:&quot; &lt;&lt; in_buff &lt;&lt; std::endl;            // 返回客户端            send(accept_fd, (void *)in_buff, MESSAGE_LEN, 0);        }        close(accept_fd);    }    close(socket_fd);    return 0;}</code></pre><h3 id="二、实现一个TCP-Client"><a href="#二、实现一个TCP-Client" class="headerlink" title="二、实现一个TCP Client"></a>二、实现一个TCP Client</h3><h5 id="Client端步骤"><a href="#Client端步骤" class="headerlink" title="Client端步骤"></a>Client端步骤</h5><ul><li>socket():创建socket，指定使用TCP协议</li><li>connect():操作系统随机分配一个随机的端口和IP地址</li><li>send():发送</li><li>recv():接收</li><li>close():关闭</li></ul><h5 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo"></a>Demo</h5><pre><code class="c++">#include &lt;iostream&gt;#include &lt;sys/socket.h&gt;  //for socket()#include &lt;sys/types.h&gt;   // for connect()#include &lt;netinet/in.h&gt;  // for struct sockaddr_in#include &lt;arpa/inet.h&gt;   // for inet_addr()#include &lt;stdio.h&gt;       // for gets()#include &lt;string.h&gt;      // for strlen()#include &lt;stdlib.h&gt;      // for exit()#define PORT 8881        // tcp server port#define MESSAGE_LEN 1024 // buffer sizeint main(int argc, char *argv[]){    int socket_fd; // file descriptor    int ret = -1;    // step1:create socket    socket_fd = socket(AF_INET, SOCK_STREAM, 0);    if (socket_fd &lt; 0)    {        std::cout &lt;&lt; &quot;failed to create socket&quot; &lt;&lt; std::endl;        exit(-1);    }    // step2: connect    struct sockaddr_in serveraddr;    serveraddr.sin_family = AF_INET;    serveraddr.sin_port = PORT;    serveraddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);    ret = connect(socket_fd, (struct sockaddr *)&amp;serveraddr, sizeof(struct sockaddr));    if (ret &lt; 0)    {        std::cout &lt;&lt; &quot;failed to connect server&quot; &lt;&lt; std::endl;        exit(-1);    }    // step3: send()    char sendbuf[MESSAGE_LEN] = {0};    char recvbuf[MESSAGE_LEN] = {0};    while (1)    {        memset(sendbuf, 0, MESSAGE_LEN); // 清空buf        gets(sendbuf);                   // input from console        ret = send(socket_fd, sendbuf, strlen(sendbuf), 0);        if (ret &lt;= 0) // 无发送数据        {            std::cout &lt;&lt; &quot;failed to send data!&quot; &lt;&lt; std::endl;            break;        }        if (strcmp(sendbuf, &quot;q&quot;) == 0) // input q, quit        {            break;        }        ret = recv(socket_fd, recvbuf, MESSAGE_LEN, 0);        recvbuf[ret] = &#39;\0&#39;; //末尾加\0转化为字符串        std::cout &lt;&lt; &quot;receive:&quot; &lt;&lt; recvbuf &lt;&lt; std::endl;    }    return 0;}</code></pre><h3 id="三、-实现UDPServer"><a href="#三、-实现UDPServer" class="headerlink" title="三、 实现UDPServer"></a>三、 实现UDPServer</h3><h5 id="Server-流程"><a href="#Server-流程" class="headerlink" title="Server 流程"></a>Server 流程</h5><ul><li>Socket():创建Socket，指定为UDP协议</li><li>bind():将socket与地址和端口绑定</li><li>不需要listen，因为udp是无连接的</li><li>recvfrom():使用recv/send </li><li>sendto(): 发送</li><li>close(): 关闭连接</li></ul><h5 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h5><pre><code class="c++">#include &lt;iostream&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt; // for struct sockaddr_in#include &lt;arpa/inet.h&gt;  // for inet_addr()#include &lt;stdlib.h&gt;#define BUFFER_SIZE 1024int main(int argc, char *argv[]){    std::cout &lt;&lt; &quot;Welcome! This is a UDP server.&quot; &lt;&lt; std::endl;    int ret = -1;    int socket_fd;    // step1: create socket    socket_fd = socket(AF_INET, SOCK_DGRAM, 0);    if (socket_fd &lt; 0)    {        std::cout &lt;&lt; &quot;create udp socket failed!&quot; &lt;&lt; std::endl;        exit(-1);    }    // step: bind    struct sockaddr_in addr;    addr.sin_family = AF_INET; // IPV4    addr.sin_port = 9876;    addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);    ret = bind(socket_fd, (sockaddr *)&amp;addr, sizeof(struct sockaddr));    if (ret &lt; 0)    {        std::cout &lt;&lt; &quot;bind addr and port failed!&quot; &lt;&lt; std::endl;        exit(-1);    }    // step3: recvfrom    struct sockaddr_in clientAddr;    socklen_t len = sizeof(clientAddr);    int n;    char recv_buf[BUFFER_SIZE] = {0};    char send_buf[BUFFER_SIZE] = {0};    while (1)    {        // receive data to recv_buf        n = recvfrom(socket_fd, recv_buf, BUFFER_SIZE, 0, (struct sockaddr *)&amp;clientAddr, &amp;len);        if (n &gt; 0)        {            recv_buf[n] = 0; //转为字符串            std::cout &lt;&lt; &quot;receive data:&quot; &lt;&lt; recv_buf &lt;&lt; std::endl;            n = sendto(socket_fd, send_buf, BUFFER_SIZE, 0, (struct sockaddr *)&amp;clientAddr, sizeof(clientAddr));            if (n &lt; 0)            {                std::cout &lt;&lt; &quot;send error!&quot; &lt;&lt; std::endl;            }        }        else        {            std::cout &lt;&lt; &quot;receive error!&quot; &lt;&lt; std::endl;        }    }    return 0;}</code></pre><h3 id="四、-实现UDP-Client"><a href="#四、-实现UDP-Client" class="headerlink" title="四、 实现UDP Client"></a>四、 实现UDP Client</h3><h5 id="Client-流程"><a href="#Client-流程" class="headerlink" title="Client 流程"></a>Client 流程</h5><ul><li>Socket():创建Socket，指定为UDP协议</li><li>sendto(): 发送</li><li>recvfrom():使用recv/send </li><li>close(): 关闭连接</li></ul><h5 id="demo-1"><a href="#demo-1" class="headerlink" title="demo"></a>demo</h5><pre><code class="c++">#include &lt;iostream&gt;#include &lt;sys/socket.h&gt; // for socket()#include &lt;stdlib.h&gt;     // for exit()#include &lt;netinet/in.h&gt; // for struct sockaddr_in#include &lt;arpa/inet.h&gt;  // for inet_addr()#include &lt;string.h&gt;     // for strlen#include &lt;unistd.h&gt;     // for close()#define BUFFER_SIZE 1024int main(int argc, char *argv[]){    // step1: socket    int socket_fq;    socket_fq = socket(AF_INET, SOCK_DGRAM, 0); // UDP是基于报文的    if (socket_fq &lt; 0)    {        std::cout &lt;&lt; &quot;create socket failed!&quot; &lt;&lt; std::endl;        exit(-1);    }    // step2:    struct sockaddr_in serverAddr;    serverAddr.sin_family = AF_INET;    serverAddr.sin_port = 9876;    serverAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);    char send_buf[BUFFER_SIZE] = &quot;hello&quot;;    char recv_buf[BUFFER_SIZE] = {0};    socklen_t len = sizeof(serverAddr);    int n = 0;    if (serverAddr.sin_addr.s_addr == INADDR_NONE)    {        std::cout &lt;&lt; &quot;Incorrect ip address!&quot; &lt;&lt; std::endl;        close(socket_fq);        exit(-1);    }    n = sendto(socket_fq, send_buf, strlen(send_buf), 0, (sockaddr *)&amp;serverAddr, sizeof(serverAddr));    if (n &lt; 0)    {        std::cout &lt;&lt; &quot;send error!&quot; &lt;&lt; std::endl;        close(socket_fq);    }    n = recvfrom(socket_fq, recv_buf, BUFFER_SIZE, 0, (sockaddr *)&amp;serverAddr, &amp;len);    if (n &gt; 0)    {        recv_buf[n] = 0;        std::cout &lt;&lt; &quot;receive:&quot; &lt;&lt; recv_buf &lt;&lt; std::endl;    }    else if (n == 0)    {        std::cout &lt;&lt; &quot;server closed.&quot; &lt;&lt; std::endl;    }    else if (n == -1)    {        std::cout &lt;&lt; &quot;recvfrom error.&quot; &lt;&lt; std::endl;    }    close(socket_fq);    return 0;}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>哎呦，不错哦；</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 高性能服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能服务器：Linux下的信号与后台守护进程</title>
      <link href="/ji-zhu/gao-xing-neng-fu-wu-qi-linux-xia-de-xin-hao-yu-hou-tai-shou-hu-jin-cheng.html"/>
      <url>/ji-zhu/gao-xing-neng-fu-wu-qi-linux-xia-de-xin-hao-yu-hou-tai-shou-hu-jin-cheng.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>有兴趣搞一搞高性能流媒体服务器了，这些得了解，学习过程中记录一下，方便未来回顾。</p></blockquote><h3 id="一、Linux-下的几个重要信号"><a href="#一、Linux-下的几个重要信号" class="headerlink" title="一、Linux 下的几个重要信号"></a>一、Linux 下的几个重要信号</h3><ul><li>SIGPIPE：管道终止信号，当写入无人读取的管道时产生该信号，默认终止进程，需要我们去处理<ul><li>网络程序必须要处理，否则Client端断开连接之后，会导致Server Crash</li></ul></li><li>SIGCHLD：子进程结束或者停止发送时候<ul><li>容易产生僵尸进程（一个早已死亡的进程，但是在进程表中还存在）</li><li>子进程结束的时候，他并没有完全销毁，因为父进程还需要使用它的消息。</li><li>父进程没有处理SIGCHLD信号，或者没有调用wait/waitpid等待子进程结束，就会出现僵尸进程。</li></ul></li><li>SIGALRM: 定时信号，秒为单位，默认会终止进程，所以需要我们去处理（捕获，然后忽略）</li><li>SIGINT: 键盘输入的退出信号</li><li>SIGQUIT： 键盘输入的退出信号</li><li>SIGHUP：控制终端挂起信号</li></ul><a id="more"></a><h3 id="二、信号的发送和处理"><a href="#二、信号的发送和处理" class="headerlink" title="二、信号的发送和处理"></a>二、信号的发送和处理</h3><ul><li>硬件方式<ul><li>ctrl+c，ctrl+\</li></ul></li></ul><h3 id="三、安装信号"><a href="#三、安装信号" class="headerlink" title="三、安装信号"></a>三、安装信号</h3><h5 id="signal-int-sig-void-func-int"><a href="#signal-int-sig-void-func-int" class="headerlink" title="signal(int sig, void (*func)(int));"></a>signal(int sig, void (*func)(int));</h5><pre><code class="c++">#include &lt;iostream&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;void sighandle(int sig){    std::cout &lt;&lt; &quot;receive signal:&quot; &lt;&lt; sig &lt;&lt; std::endl;}int main(int argc, char *argv[]){    signal(SIGINT, sighandle); // 捕获SIGINT信号    signal(SIGQUIT, sighandle);    signal(SIGHUP, sighandle);    pause();}</code></pre><h5 id="通过-sigaction方法"><a href="#通过-sigaction方法" class="headerlink" title="通过 sigaction方法"></a>通过 sigaction方法</h5><ul><li>sigaction<pre><code class="c++">struct sigaction{  void (*sa_handler)(int sig); // 捕获到sign的处理函数，需要设置  void (*sa_sigaction)(int, siginfo_t *, void *); // 与上类似，一般不用  sigset_tsa_mask; // 掩码，需要设置  int sa_flags; //根据SA_SIGINFO标记是选择sa_handler还是sigaction进行处理，需要设置};</code></pre></li><li>Demo</li></ul><pre><code class="c++">#include &lt;iostream&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;void sig_handler(int sig)   // 处理函数{    std::cout &lt;&lt; &quot;receive signal:&quot; &lt;&lt; sig &lt;&lt; std::endl;}int main(int argc, char *argcs[]){    struct sigaction act, oact;    act.sa_handler = sig_handler;    sigfillset(&amp;act.sa_mask); // 设置掩码    act.sa_flags = 0;   // 选择使用sighandler来处理    sigaction(SIGINT, &amp;act, &amp;oact);    sigaction(SIGQUIT, &amp;act, &amp;oact);    pause();    return 0;}</code></pre><h3 id="四、后台进程"><a href="#四、后台进程" class="headerlink" title="四、后台进程"></a>四、后台进程</h3><h5 id="fork方式"><a href="#fork方式" class="headerlink" title="fork方式"></a>fork方式</h5><ul><li>四个步骤<ul><li>fork 一个子进程，父进程退出了，那么子进程将成为孤儿进程，被init进程接管</li><li>调用setsid建立新的进程会话</li><li>将当前工作目录切换到更目录（因为父亲进程已经没了，init进程的工作目录在根目录）</li><li>将标准输出，输入，出错重定向到 /dev/null</li></ul></li><li>Demo 代码</li></ul><pre><code class="c++">#include &lt;iostream&gt;#include &lt;unistd.h&gt; // fork#include &lt;stdlib.h&gt; // for session#include &lt;fcntl.h&gt;  // for openvoid daemonize(){    /*step1: fork一个子进程*/    int fd;       // file descriptionor    pid_t pid;    // 进程id    pid = fork(); // 当前进程创建一个子进程，pid为子进程的id    if (pid &lt; 0)    {        std::cout &lt;&lt; &quot;can&#39;t create suprocess!&quot; &lt;&lt; std::endl;        exit(-1);    }    else    {        if (pid != 0) // 判断子进程是否创建成功，为0则创建成功，非0则为父进程        {            exit(0); // 父进程退出，子进程成为孤儿进程，被init进程接管        }    }    /*strp2: 建立新的进程会话*/    setsid(); //调用setsid来创建新的进程会话。这使得daemon进程成为会话首进程，脱离和terminal的关联。    /*step3： 切换工作目录到根目录*/    if (chdir(&quot;/&quot;) &lt; 0) // 将当前工作目录切换到根目录。父进程继承过来的当前目录可能mount在一个文件系统上    {        std::cout &lt;&lt; &quot;can&#39;t change dir!&quot; &lt;&lt; std::endl;        exit(-1);    }    // 将标准输入、输出、错位重定向到根目录    fd = open(&quot;/dev/null&quot;, O_RDWR); // O_WRWR，可读可写    dup2(fd, STDIN_FILENO);         // 重定向方法，dup2()    dup2(fd, STDOUT_FILENO);    dup2(fd, STDERR_FILENO);    return;}int main(int argc, char *argcs[]){    daemonize(); // 调取这个程序之后，就将程序切换到后台    while (1)    {        sleep(1);    }    return 0;}</code></pre><h5 id="调用系统的daemon-API"><a href="#调用系统的daemon-API" class="headerlink" title="调用系统的daemon API"></a>调用系统的daemon API</h5><ul><li>linux的系统函数，其实实际上也是走上边的四个步骤,推荐优先使用<ul><li>unistd.h中的daemon() api</li></ul></li><li>demo</li></ul><pre><code class="c++">#include &lt;iostream&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char *argcs[]){    /* Put the program in the background, and dissociate from the controlling    terminal.  If NOCHDIR is zero, do `chdir (&quot;/&quot;)&#39;.  If NOCLOSE is zero,    redirects stdin, stdout, and stderr to /dev/null.  */    if (daemon(0, 0) == -1)    {        std::cout &lt;&lt; &quot;error&quot; &lt;&lt; std::endl;        exit(-1);    }    // 以上代码便可以实现将进程切换到后台运行，之后再执行其他语句    while (1)    {        sleep(1);    }    return 0;}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>似乎对linux又友好一点了</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 高性能服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次基于OAuth 2.0的第三方登录实践总结</title>
      <link href="/ji-zhu/yi-ci-ji-yu-oauth-2-0-de-di-san-fang-deng-lu-shi-jian-2019-11-01.html"/>
      <url>/ji-zhu/yi-ci-ji-yu-oauth-2-0-de-di-san-fang-deng-lu-shi-jian-2019-11-01.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>OAuth 2.0 是目前最流行的授权机制，用来授权第三方应用，获取用户数据。</p></blockquote><h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><ul><li>最近在视频云项目的ToC观看端想引入用户登录功能。从用户需求的角度考虑，用户不喜欢仅为了发送一个弹幕或者评论而需要进行复杂的注册流程。目前很多网站都引入了第三方登录的方式，这样即解决了用户会忘记密码的问题，也简化了用户的登录流程，提高参与度。</li><li>OAuth是目前主流的授权方式，值得系统学习下。</li></ul><h3 id="二、OAuth-2-0"><a href="#二、OAuth-2-0" class="headerlink" title="二、OAuth 2.0"></a>二、OAuth 2.0</h3><h5 id="1-令牌"><a href="#1-令牌" class="headerlink" title="1. 令牌"></a>1. 令牌</h5><ul><li>OAuth中授权使用的是token，而不是密码。<ul><li>token具有时效性，可以随时被撤销，且权限范围受限</li><li>相比于密码的方式，在实现授权给第三方的同时，具有较好的可控性。</li></ul></li></ul><h5 id="2-角色"><a href="#2-角色" class="headerlink" title="2. 角色"></a>2. 角色</h5><ul><li>客户端：想要通过第三方登录的软件系统</li><li>资源所有者：授权方</li></ul><h5 id="3-授权层"><a href="#3-授权层" class="headerlink" title="3. 授权层"></a>3. 授权层</h5><ul><li>OAuth引入了授权层，来隔离这两个用户</li></ul><a id="more"></a><h3 id="三、OAuth的四种授权方式"><a href="#三、OAuth的四种授权方式" class="headerlink" title="三、OAuth的四种授权方式"></a>三、OAuth的四种授权方式</h3><ul><li>为了适应互联网各种不同的场景，OAuth提供了四种授权方式。</li><li>在授权之前，第三方系统需要到授权系统注册，说明自己的身份<ul><li>然后获得应用ID（app_id）以及应用密钥（app_secret)</li></ul></li><li>下文中A系统为授权系统，比如微信、微博，B系统为第三方应用，比如我们的视频云系统。</li></ul><h5 id="1-授权码式（authorization-code）"><a href="#1-授权码式（authorization-code）" class="headerlink" title="1. 授权码式（authorization-code）"></a>1. 授权码式（authorization-code）</h5><ul><li><p>最常用的方式，安全性也最高</p></li><li><p>需要应用后端支持，授权码由前端获取，令牌以及资源请求由后端进行，安全性高，能防止令牌泄露。</p></li><li><p>标志：response_type=code</p></li><li><p>主要流程：</p><ul><li><p>1、注册与登记</p><ul><li>B系统到A系统的OAuth开放平台注册，获得app_id以及app_secret，A授权系统会提供一个用户授权的网页链接。</li><li>注册时需要在开放平台配置redirect_uri等授权回调页以及取消授权回调页参数</li></ul></li><li><p>2、前端跳转到授权界面</p><ul><li>B系统将A系统提供的授权链接放在前端登录位置，用户点击后，将带上app_id等参数跳转到A系统的授权界面。</li><li>state参数可以用来保持B系统当前的应用状态，在授权成功之后，会原封不动的返回。state需要存多个参数的时候，可以使用urlencode编码一下。</li></ul></li><li><p>3、用户登录A系统并授权</p><ul><li>用户通过密码登录A系统，如果A系统已经是登录状态，则直接进入授权界面。授权界面会展示B系统所请求的权限以及资源，用户检查后点击授权。</li></ul></li><li><p>4、B系统前端获取授权码</p><ul><li>授权成功，前端自动跳转到redirect_uri指定的网页，同时带上code以及state等query参数。</li><li>其中code便是授权码，而state是之前传入的应用状态参数，用户恢复跳转前的应用状态。</li></ul><pre><code class="js">// a系统提供的跳转授权链接例子https://a.com/oauth/authrize?response_type=code&amp;client_id=CLIENT_ID&amp;redirect_uri=CALLBACK_RUL&amp;scope=read// 参数response_type   // 对于授权码方式为code，指定为授权码方式redirect_uri    // 授权成功之后，将跳转到该页面scope           // 指定授权的方位，这里为只读权限state           // 可以传入随意的字符串参数，可用户保持B应用当前状态</code></pre></li><li><p>5、B后端向A系统请求令牌token</p><ul><li>B前端从url中解析出code，将该code提交给B后端</li><li>B后端根据拿到的code、app_id以及app_secret向A系统提供的接口请求令牌token。</li></ul><pre><code class="js">// B后端请求Token例子  https://b.com/oauth/token?client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET&amp;grant_type=authorization_code&amp;code=AUTHORIZATION_CODE&amp;redirect_uri=CALLBACK_URL</code></pre></li><li><p>6、B后端向A系统请求资源</p><ul><li>B后端获取到token后，使用该token获取用户在A系统中的资源，比如用户名，头像等。</li></ul></li><li><p>7、B后端将结果返回给B前端,前端恢复应用状态。</p></li></ul></li></ul><h5 id="2-隐藏式（implicit）"><a href="#2-隐藏式（implicit）" class="headerlink" title="2. 隐藏式（implicit）"></a>2. 隐藏式（implicit）</h5><ul><li>不需要应用后端支持，前端直接请求令牌token，token存储在前端</li><li>适用于那些没有后端的纯前端应用，对安全性要求不高的场景，比如本博客。</li><li>token的有效期不能太长。</li><li>标志：response_type=token</li><li>主要流程<ul><li>1、注册与登记，与授权码方式相同</li><li>2、B前端跳转到A提供的授权界面<ul><li>与授权码方式不同的是，参数response_type为token，A系统将直接返回token令牌</li></ul></li><li>3、B前端获取令牌token<ul><li>授权成功之后，跳转到redirect_uri指定的网站，同时带上token</li><li>与授权码式通过query参数返回不同，token以URL锚点（fragement）的方式返回给B前端</li><li>以锚点方式返回能够避免中间人攻击问题，因为浏览器跳转时，锚点部分不会提交到服务器。</li><li><code>https://a.com/callback#token=ACCESS_TOKEN</code></li></ul></li><li>4、B前端拿到token后，向A后端请求资源。</li></ul></li></ul><h5 id="3-密码式（password）"><a href="#3-密码式（password）" class="headerlink" title="3. 密码式（password）"></a>3. 密码式（password）</h5><ul><li>B网站直接在前端要求用户输入其在A系统的用户名和密码，然后直接通过用户名和密码获取A系统颁发的token</li><li>只适用于那些你高度信任的网站，或者其他方式没法使用的情况下，比如内部系统。</li><li>标志：grant_type=password</li><li>授权链接：<code>https://oauth.b.com/token?grant_type=password&amp;username=USERNAME&amp;password=PASSWORD&amp;client_id=CLIENT_ID</code></li></ul><h5 id="4-客户端凭证式（client-credentials）"><a href="#4-客户端凭证式（client-credentials）" class="headerlink" title="4. 客户端凭证式（client credentials）"></a>4. 客户端凭证式（client credentials）</h5><ul><li>适用于没有前端的命令行应用，即在命令行下请求令牌</li><li>标志：grant_type=client_credentials</li></ul><h3 id="三、使用与更新"><a href="#三、使用与更新" class="headerlink" title="三、使用与更新"></a>三、使用与更新</h3><h5 id="1-令牌的使用"><a href="#1-令牌的使用" class="headerlink" title="1. 令牌的使用"></a>1. 令牌的使用</h5><ul><li>每个发到 API 的请求，都必须带有令牌。具体做法是在请求的头信息，加上一个Authorization字段，令牌就放在这个字段里面</li></ul><h5 id="2-令牌的更新"><a href="#2-令牌的更新" class="headerlink" title="2. 令牌的更新"></a>2. 令牌的更新</h5><ul><li>令牌有效期到期后，再来一次完整流程比较麻烦，OAuth提供了令牌更新的机制。</li><li>标志：grant_type=refresh_token</li></ul><h3 id="四、在使用OAuth时候需要注意的安全问题"><a href="#四、在使用OAuth时候需要注意的安全问题" class="headerlink" title="四、在使用OAuth时候需要注意的安全问题"></a>四、在使用OAuth时候需要注意的安全问题</h3><h5 id="1-CSRF劫持第三方账号"><a href="#1-CSRF劫持第三方账号" class="headerlink" title="1. CSRF劫持第三方账号"></a>1. CSRF劫持第三方账号</h5><ul><li>跨站请求伪造攻击<ul><li>攻击者利用自己获取到的授权码，在钓鱼网站上使用，该钓鱼网站会伪造用户请求，自动触发第三方授权过程。</li><li>使用钓鱼网站的用户，自动触发第三方授权过程，若该用户当前登录了正常系统，且未与该第三方登录绑定。</li><li>最终，正常网站将把该用户账号与攻击者第三方系统登录账号绑定，这样攻击者就可以通过第三方系统登录被攻击者的账号了。</li></ul></li><li>根本原因：redirect_uri中的code参数没有和当前客户端的状态绑定，攻击者可以通过发送预先获取好的code参数到受害者电脑，导致导致受害者当前登录的应用方账号被绑定到攻击者指定的平台方（如微博）帐号上。</li></ul><h5 id="2-预防措施"><a href="#2-预防措施" class="headerlink" title="2. 预防措施"></a>2. 预防措施</h5><ul><li>引入第三方登陆的开发者，在OAuth认证过程中，加入state参数，验证它的参数便可以。</li><li>使用state参数的流程<ul><li>在将用户重定向到资源认证服务器授权界面的时候，为当前用户生成一个随机的字符串，并作为state参数加入到URL中，同时存储一份到 session 中。</li><li>当第三方应用收到资源服务提供者返回的Authorization Code请求的时候，验证接收到的state参数值。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>OAuth 在目前的互联网应用中使用的太多了，系统性了解它的原理很有用。有空可以给本博客集成下登录和评论系统了。</li><li>再一个体会，对于一些使用了OAuth第三方登陆的不是特别出名的小网站，真不敢再随便用自己的第三方账号随便登录了。</li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="http://www.ruanyifeng.com/blog/2019/04/oauth_design.html" target="_blank" rel="noopener">[1]大神学长阮一峰的理解OAuth2.0</a></li><li><a href="https://juejin.im/post/5cc81d5451882524f72cd32c" target="_blank" rel="noopener">[2]掘金上的一个博客</a></li><li>微博、微信、QQ、github的授权认证接入文档</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux的一些进阶技能</title>
      <link href="/ji-zhu/linux-de-yi-xie-jin-jie-ji-neng-2019-11-01.html"/>
      <url>/ji-zhu/linux-de-yi-xie-jin-jie-ji-neng-2019-11-01.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>好好学学Linux，以后用得到 </p></blockquote><h3 id="一些关于Linxu想知道的疑问解决"><a href="#一些关于Linxu想知道的疑问解决" class="headerlink" title="一些关于Linxu想知道的疑问解决"></a>一些关于Linxu想知道的疑问解决</h3><h5 id="1-服务Service与Demand的区别"><a href="#1-服务Service与Demand的区别" class="headerlink" title="1. 服务Service与Demand的区别"></a>1. 服务Service与Demand的区别</h5><p>我的理解，服务是能够常驻在系统后台并提供一些系统的或者网络功能。服务其实是能够提供某个功能的意思，但是既然是一个功能，那一定需要有个程序去执行吧。Demand意思是守护的意思，它便是达成这个service的程序，Demand其实和Service也不需要完全区分。</p><a id="more"></a><h5 id="2-进程、线程以及协程的区别"><a href="#2-进程、线程以及协程的区别" class="headerlink" title="2. 进程、线程以及协程的区别"></a>2. 进程、线程以及协程的区别</h5><ul><li>进程<ul><li>是系统资源分配的最小单位, 系统由一个个进程(程序)组成。</li><li>进程的创建和销毁都是相对于系统资源,所以是一种比较昂贵的操作。</li><li>进程是抢占式的争夺CPU运行自身,而CPU单核的情况下同一时间只能执行一个进程的代码,但是多进程的实现则是通过CPU飞快的切换不同进程,因此使得看上去就像是多个进程在同时进行.</li><li>进程间的通信：不同进程之间的通信主要通过进程间调用IPC来实</li><li>进程是系统分配资源的最小单位</li></ul></li><li>线程<ul><li>线程属于进程，一个进程可以创建多个线程。</li><li>线程共享进程的内存地址空间，多个线程之间也可共享内存。</li><li>线程间的通信：进程相当于一个容器，其中的线程都可以访问容器中的东西。所以线程间的通信可以直接通过全局变量来通信。</li><li>引入锁机制：解决多个线程同时读写一个地址变量带来的不可预期的后果。</li><li>线程是CPU调度的最小单位。</li></ul></li><li>协程<ul><li>协程是属于线程的，协程程序在线程中运行，也叫微线程。</li><li>协程没有线程的上下文切换消耗。协程的调度切换是用户(程序员)手动切换的,因此更加灵活,因此又叫用户空间线程.</li><li>原子操作性。由于协程是用户调度的，所以不会出现执行一半的代码片段被强制中断了，因此无需原子操作锁。</li><li>线程进程都是同步机制，而协程则是异步</li></ul></li></ul><h3 id="Linux服务"><a href="#Linux服务" class="headerlink" title="Linux服务"></a>Linux服务</h3><h5 id="1-定时任务服务-crontab"><a href="#1-定时任务服务-crontab" class="headerlink" title="1. 定时任务服务 crontab"></a>1. 定时任务服务 crontab</h5><ul><li>比如在下订单之后，会有30分钟的支付时间，过期之后，取消订单。</li></ul><h5 id="2-日期同步服务-Ntpdate"><a href="#2-日期同步服务-Ntpdate" class="headerlink" title="2. 日期同步服务 Ntpdate"></a>2. 日期同步服务 Ntpdate</h5><p>-</p><h5 id="3-日志切割服务-Logrotate"><a href="#3-日志切割服务-Logrotate" class="headerlink" title="3. 日志切割服务 Logrotate"></a>3. 日志切割服务 Logrotate</h5><p>-</p><h5 id="4-进程管理-supervisor"><a href="#4-进程管理-supervisor" class="headerlink" title="4. 进程管理 supervisor"></a>4. 进程管理 supervisor</h5><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>好好学学Linux，以后用得到</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 解压命令汇总</title>
      <link href="/ji-zhu/linux-jie-ya-ming-ling-hui-zong-2019-11-01.html"/>
      <url>/ji-zhu/linux-jie-ya-ming-ling-hui-zong-2019-11-01.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>搞定Linux文件打包、解压、压缩</p></blockquote><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><ul><li>解包：tar xvf FileName.tar</li><li>打包：tar cvf FileName.tar DirName</li><li>（注：tar是打包，不是压缩！）</li></ul><a id="more"></a><h3 id="gz"><a href="#gz" class="headerlink" title=".gz"></a>.gz</h3><ul><li>解压1：gunzip FileName.gz</li><li>解压2：gzip -d FileName.gz</li><li>压缩：gzip FileName</li></ul><h3 id="tar-gz-和-tgz"><a href="#tar-gz-和-tgz" class="headerlink" title=".tar.gz 和 .tgz"></a>.tar.gz 和 .tgz</h3><ul><li>解压：tar zxvf FileName.tar.gz</li><li>压缩：tar zcvf FileName.tar.gz DirName</li></ul><h3 id="bz2"><a href="#bz2" class="headerlink" title=".bz2"></a>.bz2</h3><ul><li>解压1：bzip2 -d FileName.bz2</li><li>解压2：bunzip2 FileName.bz2</li><li>压缩： bzip2 -z FileName</li></ul><h3 id="tar-bz2"><a href="#tar-bz2" class="headerlink" title=".tar.bz2"></a>.tar.bz2</h3><ul><li>解压：tar jxvf FileName.tar.bz2</li><li>压缩：tar jcvf FileName.tar.bz2 DirName</li></ul><h3 id="bz"><a href="#bz" class="headerlink" title=".bz"></a>.bz</h3><ul><li>解压1：bzip2 -d FileName.bz</li><li>解压2：bunzip2 FileName.bz</li><li>压缩：未知</li></ul><h3 id="tar-bz"><a href="#tar-bz" class="headerlink" title=".tar.bz"></a>.tar.bz</h3><ul><li>解压：tar jxvf FileName.tar.bz</li><li>压缩：未知</li></ul><h3 id="Z"><a href="#Z" class="headerlink" title=".Z"></a>.Z</h3><ul><li>解压：uncompress FileName.Z</li><li>压缩：compress FileName</li></ul><h3 id="tar-Z"><a href="#tar-Z" class="headerlink" title=".tar.Z"></a>.tar.Z</h3><ul><li>解压：tar Zxvf FileName.tar.Z</li><li>压缩：tar Zcvf FileName.tar.Z DirName</li></ul><h3 id="zip"><a href="#zip" class="headerlink" title=".zip"></a>.zip</h3><ul><li>解压：unzip FileName.zip</li><li>压缩：zip FileName.zip DirName</li></ul><h3 id="rar"><a href="#rar" class="headerlink" title=".rar"></a>.rar</h3><ul><li>解压：rar x FileName.rar</li><li>压缩：rar a FileName.rar DirName</li></ul><h3 id="lha"><a href="#lha" class="headerlink" title=".lha"></a>.lha</h3><ul><li>解压：lha -e FileName.lha</li><li>压缩：lha -a FileName.lha FileName</li></ul><h3 id="rpm"><a href="#rpm" class="headerlink" title=".rpm"></a>.rpm</h3><ul><li>解包：rpm2cpio FileName.rpm | cpio -div</li></ul><h3 id="deb"><a href="#deb" class="headerlink" title=".deb"></a>.deb</h3><ul><li>解包：ar p FileName.deb data.tar.gz | tar zxf -</li></ul><h3 id="gzip-命令"><a href="#gzip-命令" class="headerlink" title="gzip 命令"></a>gzip 命令</h3><ul><li><p>减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。gzip 是在 Linux 系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。</p></li><li><p>语法：gzip [选项] 压缩（解压缩）的文件名该命令的各选项含义如下：</p></li><li><p>-c 将输出写到标准输出上，并保留原有文件。-d 将压缩文件解压。-l 对每个压缩文件，显示下列字段：     压缩文件的大小；未压缩文件的大小；压缩比；未压缩文件的名字-r 递归式地查找指定目录并压缩其中的所有文件或者是解压缩。-t 测试，检查压缩文件是否完整。-v 对每一个压缩和解压的文件，显示文件名和压缩比。-num 用指定的数字 num 调整压缩的速度，-1 或 –fast 表示最快压缩方法（低压缩比），-9 或–best表示最慢压缩方法（高压缩比）。系统缺省值为 6。指令实例：</p></li><li><p>gzip *% 把当前目录下的每个文件压缩成 .gz 文件。gzip -dv *% 把当前目录下每个压缩的文件解压，并列出详细的信息。gzip -l *% 详细显示例1中每个压缩的文件的信息，并不解压。gzip usr.tar% 压缩 tar 备份文件 usr.tar，此时压缩文件的扩展名为.tar.gz。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实都可以直接查到，争取早日孰能生巧吧。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web-rtc技术基础</title>
      <link href="/ji-zhu/web-rtc-ji-zhu-ji-chu-2019-10-30.html"/>
      <url>/ji-zhu/web-rtc-ji-zhu-ji-chu-2019-10-30.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>背景<br>5G时代，是时候玩玩WebRTC了吧</p></blockquote><h3 id="一、-WebRTC基础"><a href="#一、-WebRTC基础" class="headerlink" title="一、 WebRTC基础"></a>一、 WebRTC基础</h3><h5 id="1-关于WebRTC的关键词"><a href="#1-关于WebRTC的关键词" class="headerlink" title="1. 关于WebRTC的关键词"></a>1. 关于WebRTC的关键词</h5><ul><li>Google开源，跨平台，多媒体框架</li><li>音视频处理+即时通讯的开源库</li><li>浏览器之间端到端之间实时数据传输</li><li>音视频引擎：编码、采集等</li></ul><a id="more"></a><h5 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h5><ul><li>实时视频会议，在线教育，共享远程桌面，录制，即时通讯，P2P网络加速，实时人脸识别，游戏</li><li>浏览器+WebRTC是未来</li></ul><h5 id="3-浏览器支持情况"><a href="#3-浏览器支持情况" class="headerlink" title="3. 浏览器支持情况"></a>3. 浏览器支持情况</h5><ul><li>Chrome，Safari，Firefox，Edge</li></ul><h5 id="4-WebRTC的能力和优势"><a href="#4-WebRTC的能力和优势" class="headerlink" title="4. WebRTC的能力和优势"></a>4. WebRTC的能力和优势</h5><ul><li>能力<ul><li>音视频设备管理</li><li>音视频数据采集</li><li>数据传输与实时互动</li></ul></li><li>优势  <ul><li>音视频实时传输</li><li>游戏、即时通讯、文件传输（P2P传输）</li><li>回音消除，降噪</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>内容</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音视频 </tag>
            
            <tag> WebRTC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FFmpeg 二次开发</title>
      <link href="/ji-zhu/ffmpeg-er-ci-kai-fa-2019-10-30.html"/>
      <url>/ji-zhu/ffmpeg-er-ci-kai-fa-2019-10-30.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、FFmpeg"><a href="#一、FFmpeg" class="headerlink" title="一、FFmpeg"></a>一、FFmpeg</h3><h5 id="1-代码结构"><a href="#1-代码结构" class="headerlink" title="1. 代码结构"></a>1. 代码结构</h5><ul><li>libacvdec<ul><li>提供了一系列编码器的实现</li><li>如果需要提供自己的编码，在此基础上进行二次开发</li></ul></li><li>libavformat<ul><li>实现在流协议、容器格式以及基本的IO访问</li></ul></li><li>libavutil<ul><li>提供了Hash器，解码器和各种工具函数</li></ul></li><li>libavfilter<ul><li>提供各种音视频过滤器</li></ul></li><li>libavdevice<ul><li>提供捕获设别的接口</li></ul></li><li>libswresample<ul><li>实现混音和重采样</li></ul></li><li>libswscale<ul><li>实现了色彩转换和缩放功能</li></ul></li></ul><a id="more"></a><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>内容</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音视频 </tag>
            
            <tag> FFmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim 编辑器</title>
      <link href="/ji-zhu/vim-bian-ji-qi-2019-10-30.html"/>
      <url>/ji-zhu/vim-bian-ji-qi-2019-10-30.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>背景知识</p><ul><li>手不需要移开键盘的编程方法</li></ul></blockquote><h3 id="Vim基础"><a href="#Vim基础" class="headerlink" title="Vim基础"></a>Vim基础</h3><h5 id="1-两种模式"><a href="#1-两种模式" class="headerlink" title="1. 两种模式"></a>1. 两种模式</h5><ul><li>命令模式<ul><li>拷贝、删除、粘贴</li><li>通过 i（insert） 或者 a（append） 进行切换,一般都是用i</li></ul></li><li>编辑模式<ul><li>编辑字符，</li><li>通过Esc进行切换</li></ul></li></ul><a id="more"></a><h3 id="二、常用命令"><a href="#二、常用命令" class="headerlink" title="二、常用命令"></a>二、常用命令</h3><h5 id="1-基础命令"><a href="#1-基础命令" class="headerlink" title="1. 基础命令"></a>1. 基础命令</h5><ul><li>创建文件<ul><li>vim filename</li></ul></li><li>保存文件<ul><li>:w</li></ul></li><li>关闭文件<ul><li>:q</li></ul></li><li>拷贝<ul><li>命令模式下</li><li>yy  拷贝当前光标所在的一行</li><li>yw  拷贝当前光标所在的一个单词,需要位于单词的第一个字母 </li></ul></li><li>粘贴<ul><li>p</li></ul></li><li>删除<ul><li>dd 删除当前光标所在的一行</li><li>dw 删除当前光标所在的单词</li></ul></li><li>撤销更改<ul><li>小写u</li></ul></li><li>反撤销<ul><li>Ctrl + r</li></ul></li></ul><h3 id="2-移动光标"><a href="#2-移动光标" class="headerlink" title="2. 移动光标"></a>2. 移动光标</h3><ul><li>上下左右移动，命令模式下<ul><li>h 左移</li><li>j 上</li><li>k 右</li><li>l 下</li></ul></li><li>跳到文件头<ul><li>gg</li></ul></li><li>跳到文件尾巴<ul><li>GG</li></ul></li><li>移动到行首<ul><li>^</li></ul></li><li>移动到行尾<ul><li>$</li></ul></li><li>按单词移动<ul><li>w 向前</li><li>b 向后</li></ul></li></ul><h5 id="3-查找与替换"><a href="#3-查找与替换" class="headerlink" title="3. 查找与替换"></a>3. 查找与替换</h5><ul><li>查找关键词，命令模式<ul><li>/key</li></ul></li><li>查找并替换<ul><li>%s/查找key/替换key/gc</li><li>gc用户决定每次匹配是否需要替换（y替换，n不替换）</li></ul></li></ul><h5 id="4-Vim-多窗口"><a href="#4-Vim-多窗口" class="headerlink" title="4. Vim 多窗口"></a>4. Vim 多窗口</h5><ul><li>分窗口命令<ul><li>split</li><li>vsplit</li></ul></li><li>窗口间切换<ul><li>ctrl + w</li></ul></li></ul><h5 id="5-其他操作"><a href="#5-其他操作" class="headerlink" title="5. 其他操作"></a>5. 其他操作</h5><ul><li>展示行号<ul><li>set number</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>对于Vim编辑器的学习和使用，没有什么诀窍，就是多积累，多用</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 效率工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FFmpeg 技术基础</title>
      <link href="/ji-zhu/ffmpeg-ji-zhu-ji-chu-2019-10-27.html"/>
      <url>/ji-zhu/ffmpeg-ji-zhu-ji-chu-2019-10-27.html</url>
      
        <content type="html"><![CDATA[<h3 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h3><p>格式工厂居然被FFmpeg拉黑名单了，因为没有遵守开源协议，转身就把它卸载了。</p><h3 id="一、FFmpeg基础"><a href="#一、FFmpeg基础" class="headerlink" title="一、FFmpeg基础"></a>一、FFmpeg基础</h3><h5 id="1-FFmpeg处理音视频的流程"><a href="#1-FFmpeg处理音视频的流程" class="headerlink" title="1. FFmpeg处理音视频的流程"></a>1. FFmpeg处理音视频的流程</h5><ul><li>解复用(demuxer)：带封装格式的输入文件-&gt;编码数据包（音频，视频，字幕等）</li><li>解码(decoder)：编码数据包-&gt;解码后的数据帧</li><li>处理（processer）：对数据帧进行处理，比如转码、转分辨率、转帧率、加滤镜等</li><li>编码（encoder）：解码数据帧-&gt;编码数据包</li><li>复用（muxer）：编码数据包-&gt;输出带封装格式的文件</li><li>注意：<ul><li>对于转封装这样的操作，不需要进行处理操作，所以不需要进行解码和编码操作，demuxer之后直接muxer就可以。</li></ul></li></ul><a id="more"></a><h3 id="常用FFmpeg命令"><a href="#常用FFmpeg命令" class="headerlink" title="常用FFmpeg命令"></a>常用FFmpeg命令</h3><h5 id="1-基本信息查询类"><a href="#1-基本信息查询类" class="headerlink" title="1. 基本信息查询类"></a>1. 基本信息查询类</h5><pre><code>-version-devices:显示可用设备-formats：支持的文件-muxer -demuxer：支持的封装和解封装-codecs -decoders：编解码器-filters：支持的所有过滤器</code></pre><h5 id="2-FFmpeg录制命令"><a href="#2-FFmpeg录制命令" class="headerlink" title="2. FFmpeg录制命令"></a>2. FFmpeg录制命令</h5><pre><code>// MAC 平台录制视频ffmpeg -f avfoundation -i 1 -r 30 out.yuv// 参数用法-f // 格式，采用mac提供的avfoundation库来采集视频-i // 指定从哪里采集数据，1为屏幕设备的索引值，屏幕为1，摄像头为0-r // 指定帧率，这里为30帧// 播放录制的视频ffplay -video_size 2560x1600 -pix_fmt yuv420p out.yuv// 录制声音ffmpeg -f avfoundation -i :1 out.wav// 播放录制的声音ffplay out.wav</code></pre><h5 id="3-FFmpeg-分解与复用处理（媒体格式转换）"><a href="#3-FFmpeg-分解与复用处理（媒体格式转换）" class="headerlink" title="3. FFmpeg 分解与复用处理（媒体格式转换）"></a>3. FFmpeg 分解与复用处理（媒体格式转换）</h5><ul><li>一般的封装格式转换转换，比如.mp4转.flv</li></ul><pre><code>// mp4转flv,这个的处理速度会非常的快ffmpeg -i input.mp4 -vcodec copy -acodec copy out.flv//参数介绍-vcodec copy // 视频编解码直接拷贝，不做更改-acodec copy // 音频编解码也不做更改</code></pre><ul><li>从视频中仅抽取视频或者音频</li></ul><pre><code>// 抽取已有视频流和音频流ffmpeg -i input.mp4 -an -vcodec copy out.h254ffmpeg -i input.mp4 -vn -acodec copy out.aac // 格式需要和视频中音频流的格式相同// 参数介绍-an: audio no,不要音频-vn: video no,不要视频</code></pre><h5 id="4-FFmpeg处理原始数据命令"><a href="#4-FFmpeg处理原始数据命令" class="headerlink" title="4. FFmpeg处理原始数据命令"></a>4. FFmpeg处理原始数据命令</h5><ul><li>原始数据<ul><li>视频原始数据：YUV数据</li><li>音频原视数据：PCM数据</li></ul></li><li>原始数据的提取是之后对音视频进行进一步处理的基础</li><li>提取YUV数据<ul><li>这个过程会有些长，因为涉及到编解码了</li></ul></li></ul><pre><code>// 提取YUV数据ffmpeg -i input.mp4 -an -c:v rawvideo -pix_fmt yuv420p out.yuv// 参数意义-c:v rawvideo     // 指定视频的编码器，选择rawvideo编解码器，得到YUV-pix_fmt yuv420p  // 指定像素格式，这里一般指定为yuv420p （YUV4：2：0格式）// 播放YUV数据ffplay -video_size 2560x1600 -pix_fmt yuv420p out.yuv</code></pre><ul><li>提取PCM音频原视数据</li></ul><pre><code>// 提取PCMffmpeg -i input.mp4 -vn -ar 44100 -ac 2 -f s16le out.pcm// 参数意义-ar 44100   // 设置音频采样率，常用的采样率，44.1kHZ，48kHZ，32kHZ，16kHZ-ac 2       // 设置声道-f s16le    // 指定pcm数据的存储格式// 播放PCMffplay -ar 44100 -ac 2 -f s16le out.pcm </code></pre><h5 id="5-FFmpeg滤镜命令"><a href="#5-FFmpeg滤镜命令" class="headerlink" title="5. FFmpeg滤镜命令"></a>5. FFmpeg滤镜命令</h5><ul><li>基于avfilter组件，多用于多媒体的处理与编辑</li><li>可以实现加水印，去水印，画中画，裁剪，倍速播放</li><li>滤镜的工作原理<ul><li>对解码后的数据帧再进行过滤（处理）</li><li>对过滤后的帧再进行编码</li></ul></li><li>视频裁剪命令</li></ul><pre><code>ffmpeg -i input.mp4 -vf crop=in_w-200:in_h-200 -c:v libx264 -c:a copy out// 参数使用-vf crop=in_w-200:in_h-200  // 指定滤镜名字为裁剪，之后为该滤镜的参数，宽高为200-c:v libx264                // 指定视频处理的编码器-c:a copy                   // 音频不做处理</code></pre><ul><li>视频加水印命令</li></ul><pre><code>// movie滤镜，添加水印ffmpeg -i input.flv -preset veryslow -c:v libx264 -c:a copy -vf &quot;movie=pic.png[wm];[in][wm] overlay=100:100[out]&quot; overlay.flv// 参数使用-preset veryslow  // 慢模式，最终视频质量损失较低</code></pre><h5 id="6-FFmpeg裁剪与合并命令"><a href="#6-FFmpeg裁剪与合并命令" class="headerlink" title="6. FFmpeg裁剪与合并命令"></a>6. FFmpeg裁剪与合并命令</h5><ul><li>视频裁剪命令</li></ul><pre><code>// 基于开始时间和时长进行裁剪ffmpeg -i input.flv -ss 00:00:00 -t 10 out.ts// 参数使用-ss 00:00:00  // 指定开始裁剪的时间，时：分：秒-t  10        // 裁剪的时长，以秒为单位</code></pre><ul><li>视频拼接命令</li></ul><pre><code>// 视频拼接命令ffmpeg -f concat -i input.txt out.flv// 参数-f concat       // 指定为拼接-i inputs.txt   //指定视频列表的文件// input.txt文件内容file &#39;1.ts&#39;file &#39;2.ts&#39;</code></pre><h5 id="7-图片-视频互转"><a href="#7-图片-视频互转" class="headerlink" title="7. 图片/视频互转"></a>7. 图片/视频互转</h5><ul><li>视频转图片</li></ul><pre><code>// 视频转多张图片序列ffmpeg -i input.flv -r 1 -f image2 image-%3d.jpeg// 参数使用-r 1    // 指定转换图片的频率，每秒转出一张-f image2 //  指定图片的输出格式image-%3d.jepg  // 文件名以image-加三个动态数字</code></pre><ul><li>多张图片序列转视频</li></ul><pre><code>// 图片转视频ffmpeg -i image-%3d.jpeg -r 1 out.mp4</code></pre><h5 id="8-直播相关的命令"><a href="#8-直播相关的命令" class="headerlink" title="8. 直播相关的命令"></a>8. 直播相关的命令</h5><ul><li>直播推流</li></ul><pre><code>ffmpeg -re -i input.mp4 -c copy -f flv rtmp://ip:1935/live/stream_name//参数-re   // 减慢推流帧率速度, 如果不加的话，ffmpeg会把所有数据一股脑的把所有的数据推出去。本来一个2分钟的视频 他可能几秒钟就推完了-f flv 需要指定输出的格式为rtmp</code></pre><pre><code>ffmpeg -i rtmp://ip:1935/live/stream_name -c copy video.flv</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>内容</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音视频 </tag>
            
            <tag> FFmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React前端项目的Docker化</title>
      <link href="/ji-zhu/react-qian-duan-xiang-mu-de-docker-hua-2019-10-26.html"/>
      <url>/ji-zhu/react-qian-duan-xiang-mu-de-docker-hua-2019-10-26.html</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>之前的整个视频云项目都是直接部署在实验室的服务器上，前端直接通过Nginx进行部署（运用反向代理）。现在需要将开发完成的项目整体迁移到阿里云上进行部署，能够通过外网IP和域名进行访问。</p><h3 id="为什么要前端Docker化"><a href="#为什么要前端Docker化" class="headerlink" title="为什么要前端Docker化"></a>为什么要前端Docker化</h3><p>在进行选型的时候，选择了阿里云提供的Kubernetes容器计算服务，因为相比直接购买ECS云主机或者轻量云服务器，更适合我们项目前期的低使用率以及后期的可扩展性需求，不必花费几千元仅购买了个性能较强的云主机。并且将服务拆分为一个个小小的Docker中也更便于项目的运维和部署。</p><a id="more"></a><h3 id="前端Docker化思路"><a href="#前端Docker化思路" class="headerlink" title="前端Docker化思路"></a>前端Docker化思路</h3><h5 id="1-前端镜像形式"><a href="#1-前端镜像形式" class="headerlink" title="1. 前端镜像形式"></a>1. 前端镜像形式</h5><ul><li>以Nginx为基础镜像</li><li>将前端打包完成后的build内容copy到镜像中</li><li>将Nginx的配置文件Copy到镜像中的对应位置</li><li>启动nginx服务，对外暴露80端口</li></ul><h5 id="2-前端打包过程也要在构建中进行"><a href="#2-前端打包过程也要在构建中进行" class="headerlink" title="2. 前端打包过程也要在构建中进行"></a>2. 前端打包过程也要在构建中进行</h5><ul><li>直接将打包完成的build文件Copy进镜像是可行的，但是如果想使用阿里云提供的容器镜像仓库的自动构建服务，需要将前端的打包过程也在镜像构建的过程中进行。</li><li>我们知道，最终的前端镜像中不需要那些用于打包的各种依赖，并且实际上我们的代码仓库中，node_modules等依赖并没有添加到git仓库中。</li><li>Docker构建可以分阶段进行：也就是构建过程分为build环境和最终的production环境。</li><li>而通过Dockerfile正好支持这样的构建方式</li></ul><h3 id="所使用的Dockerfile文件"><a href="#所使用的Dockerfile文件" class="headerlink" title="所使用的Dockerfile文件"></a>所使用的Dockerfile文件</h3><pre><code class="dockerfile"># build environmentFROM       node as buildWORKDIR    /appENV        PATH /app/node_modules/.bin:$PATHCOPY       . /appRUN        yarnRUN       yarn build# production environmentFROM       nginxCOPY      --from=build /app/build /usr/share/nginx/htmlRUN       rm /etc/nginx/conf.d/default.confCOPY       deploy/nginx.conf /etc/nginx/conf.dEXPOSE     80CMD       [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot; ]</code></pre><h3 id="所使用的Nginx配置文件"><a href="#所使用的Nginx配置文件" class="headerlink" title="所使用的Nginx配置文件"></a>所使用的Nginx配置文件</h3><pre><code># deploy/nginx.confserver {    listen 80;    location / {        root    /usr/share/nginx/html;        index     index.html    index.htm;        try_files $uri $uri/    /index.html;    }    error_page 500 502 503 504    /50x.html;    location = /50x.html {        root    /usr/share/nginx/html;    }}</code></pre><h3 id="问题与思考"><a href="#问题与思考" class="headerlink" title="问题与思考"></a>问题与思考</h3><h5 id="1-镜像的构建过程太漫长了"><a href="#1-镜像的构建过程太漫长了" class="headerlink" title="1. 镜像的构建过程太漫长了"></a>1. 镜像的构建过程太漫长了</h5><ul><li>主要时间大部分都用在了build环节，并且是依赖安装环节</li><li>缩减构建时间很重要</li><li>优化思路<ul><li>项目中有很多多余的依赖，去除这些未使用的依赖</li><li>更换yarn依赖安装的源（阿里似乎已经帮我们更换了）</li><li>区分依赖区分开发环境和生产环境，比如类似eslint这样的依赖，在生产打包中就不需要了。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后，由衷感受，Docker真是个好东西，搞技术的都应该学一下。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> React </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大脑Cahce系列--前端JavaScript系统梳理</title>
      <link href="/da-nao-cache/qian-duan-javascript-xi-tong-shu-li-2019-10-14.html"/>
      <url>/da-nao-cache/qian-duan-javascript-xi-tong-shu-li-2019-10-14.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>背景知识</p><ul><li>本文依然按照以往的风格，更注重JavaScript技术的系统性梳理，不赘述技术细节，因为Google一下就好。</li></ul></blockquote><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h5 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h5><ul><li>JavaScript：ES5/6 + DOM + BOM<ul><li>ECMAScript 5 2015（ES6）</li><li>DOM: 针对HTML的编程接口</li><li>BOM：对浏览器进行操作的编程接口</li></ul></li><li>浏览器内核<ul><li>渲染引擎：Blink、Webkit（用于浏览器）</li><li>JS引擎：V8引擎</li></ul></li><li>标识符</li><li>strict mode<ul><li>严格模式：添加“use strict”</li><li>让代码变得更可靠</li><li>使用方式：全局使用，局部使用（在方法中使用）</li><li>推荐编写代码的时候使用严格模式</li></ul></li></ul><a id="more"></a><ul><li>语句<ul><li>表达式语句：习惯—最好以分号结尾</li><li>流控制语句：for-in, with</li><li>异常处理语句：</li><li>返回值：</li></ul></li><li>变量<ul><li>局部变量：需要添加var，没有的话会升级为全局变量</li><li>全局变量：</li></ul></li><li>数据类型：<ul><li>5种基础数据类型（undifend、null、Boolean、Number、String），以及Object。只限制这6种形式，不存在其他类型的类型</li><li>typeof运算符：不是函数，返回值为字符串（undefined, boolean, string, number, object, function）</li><li>undefined: 变量被声明但是未初始化</li><li>null: 空对象指针。当我们声明一个变量是为了保存一个对象时，但是没法立即给他初始化时候，最好把它设置为null，这样就知道未来这个变量是变量。</li><li>Number与String数据类型转换</li><li>Object类型：创建</li></ul></li><li>运算符<ul><li>JS种的奇技淫巧都来自于对运算符的使用</li><li>基础的运算符，和其他语言一样</li><li>布尔运算（!!取bool值,&amp;&amp;短路操作,||默认值）</li><li>相等运算符：相等（==，!=）,全等（===，!==）,他们的不同。</li><li>条件运算符</li></ul></li><li>函数<ul><li>function 声明</li><li>参数：arguments，参数都是值传递的（copy简单值，copy对象和函数指针），其实就是局部变量</li><li>没有函数重载，（不过可以通过模拟函数实现：通过对arguments进行解析判断）</li></ul></li></ul><h5 id="2-引用类型"><a href="#2-引用类型" class="headerlink" title="2.引用类型"></a>2.引用类型</h5><ul><li>Object</li></ul><pre><code>{} 等价于 new Object()a.b 等价于 a[b]</code></pre><ul><li>Array</li></ul><pre><code>[] 等价于 new Array()array.length</code></pre><ul><li>判断是否是Array的两种方法：instanceof，isArray</li><li>typeof VS instanceof<ul><li>Date：+ new Date() 得到时间戳</li><li>RegExp: 正则表达式</li><li>Function</li><li>单例内置对象</li></ul></li><li>window</li><li>Math</li></ul><h5 id="3-作用域"><a href="#3-作用域" class="headerlink" title="3. 作用域"></a>3. 作用域</h5><ul><li>作用域链<ul><li>从外向内部的链条，内部可以访问外部，外部无法访问内部。内部没查找到，则向上外层继续查找</li></ul></li><li>this作用域：永远指向最后调用它的对象，具有一定的作用域。</li><li>bind():可以为函数调用绑定一个作用域（实际是一个对象）</li><li>没有块级作用域！！！，花括号无法延长作用域，只可以通过函数的方式来增加作用域</li><li>闭包：有权访问另一个函数作用域中的变量的函数</li></ul><pre><code class="js">function applyArr(){  var arr = [];  for(var i=0; i &lt; 10; i++){  // 不存在块作用域，不会新增作用域    // 不使用闭包    arr.push(function(){  //使用的i是applyArr的作用域，      return i;           // 最终在外部执行的时候，i取值一直都是10    })    // 使用闭包    (function(index){     // 通过函数构造一个新的作用域,并将i作为参数传入      arr.push(function(){        return index;     // 这样return返回的时候，取得是新创建作用域中的值      })    })(i);  }  return arr;}var arr = applyArr();var b = arr[1]();// 如果不使用闭包，那么b最终的值为10// 使用闭包后，b的值为1</code></pre><h5 id="4-面向对象的JavaScript"><a href="#4-面向对象的JavaScript" class="headerlink" title="4. 面向对象的JavaScript"></a>4. 面向对象的JavaScript</h5><ul><li>对象属性<ul><li>一般方法：直接赋值新增属性</li><li>数据属性：Object.defineProperty(obj,”name”,{configurable,enumerable,writable,value});</li><li>访问器属性：get，set</li></ul></li><li>创建对象<ul><li>工厂模式</li><li>构造函数模式</li><li>原型模式：prototype</li><li>构造函数与原型组合构造：属性放在构造函数中，方法放在原型中</li></ul></li><li>实例属性和原型属性<ul><li>in：“name” in obj， 用来判断实例obj是否有name属性</li><li>obj.hasOwnProperty(“name”): 用来判断在实例化之后的对象上，目标的属性是否是实例属性or实例方法。</li></ul></li><li>对象继承<ul><li>基于原型链的继承：缺点，属性也被继承了，继承的属性在子类中是原型属性</li><li>基于构造函数的继承：父类方法在子类中拷贝，资源浪费。</li><li>组合继承：</li></ul></li></ul><h5 id="5-DOM编程"><a href="#5-DOM编程" class="headerlink" title="5. DOM编程"></a>5. DOM编程</h5><ul><li>DOM节点<ul><li>节点间的关系：父子，兄弟</li><li>节点特征：nodeType,nodeName,nodeValue,parentNode…</li></ul></li><li>document节点的属性<ul><li>document.title：页面标题</li><li>document.referrer：来自于那个页面，用于安全性判断，防盗链</li><li>document.domain：解决域不同的问题</li></ul></li><li>DOM元素节点的默认属性<ul><li>.id</li><li>.className</li><li>.title</li><li>.lang：文本</li><li>.dir</li><li>.getAttribute(‘id’)</li></ul></li><li>DOM操作<ul><li>创建：document.createElement(“div”);</li><li>添加：someNode.appendChild(newNode);</li><li>插入：someNode.insertBefore(newNode,beforeChildNode);</li><li>替换：someNode.replaceChild(newNode,firstChild)</li><li>删除：someNode.remove(someNode.firstNode);</li><li>查找：document.getElementById(‘id’); document.getElementsByTagName()</li></ul></li></ul><h5 id="6-事件"><a href="#6-事件" class="headerlink" title="6. 事件"></a>6. 事件</h5><ul><li>事件流<ul><li>用来判断页面的哪一个部分会拥有某个特定的事件，即事件的定位</li><li>事件流：冒泡<ul><li>逐级向上级传递，接收和处理</li></ul></li><li>事件流：捕获<ul><li>从顶层节点向下传递，接收和处理</li></ul></li><li>DOM事件流：组合了冒泡<ul><li>先是捕获阶段，然后冒泡阶段，每个几点有两次处理事件的机会。</li></ul></li></ul></li><li>事件处理<ul><li>HTML标签中：比如onclick</li><li>DOM0事件处理：domElement.onclick = function…</li><li>DOM2事件处理：element.addEventListener(“click”,function()…, true/false),第三个参数指明是在捕获阶段true还是冒泡阶段处理事件。先绑定的事件先处理。</li></ul></li><li>事件处理跨浏览器<ul><li>封装跨浏览器的事件处理方法，比如安卓控制网页中的事件。</li></ul></li><li>event属性方法<ul><li>e.stopPropagation()：阻止事件冒泡</li><li>e.preventDefault(); 阻止一些默认事件</li></ul></li><li>事件类型<ul><li>各种事件，用的时候查</li><li>PC事件和移动端事件</li></ul></li></ul><h5 id="7-JSON数据通信"><a href="#7-JSON数据通信" class="headerlink" title="7. JSON数据通信"></a>7. JSON数据通信</h5><ul><li><p>JSON</p><ul><li>JSON是一种数据格式，和XML是编程语言</li><li>JSON更高效</li><li>JSON无法表示undifend类型</li><li>JSON字符串是双引号</li><li>JSON中的对象的属性也必须是字符串</li><li>JSON.stringify(obj)：将js对象序列化成json字符串</li><li>JSON.parse(jsonText,function(key,value))：解析JSON，第二个参数为解析函数</li></ul></li><li><p>AJAX</p><ul><li>异步加载</li><li>无需前端界面刷新</li></ul></li></ul><pre><code class="js">var xhr = new XMLHttpRequest();xhr.open(&quot;get&quot;,&quot;url&quot;,false); // 请求是否异步【异步：请求期间可以执行后续js，同步：不允许请求期间执行后续js】xhr.send(&quot;&quot;);// 同步的话xhr.statusxhr.responseText// 异步的话xhr.onreadystatechange = function(){  //在执行的过程中会不断执行onreadystatechange  if(xhr.readyState === 4){ //0.未初始化，1.启动，2.发送，3.接收，4.完成    xhr.status    xhr.responseText  }}</code></pre><h3 id="三、ES6"><a href="#三、ES6" class="headerlink" title="三、ES6"></a>三、ES6</h3><h5 id="1-历史"><a href="#1-历史" class="headerlink" title="1. 历史"></a>1. 历史</h5><ul><li>ES发展<ul><li>ES5</li><li>ES6 = ES2015</li><li>ES2015… 一年一更</li></ul></li><li>Evergreen浏览器<ul><li>IE，chrome，firefox，opera…</li></ul></li><li>环境<ul><li>Node：执行环境</li><li>NPM： 依赖以及包管理工具</li><li>Babel：ECMASCRIPT的转译器，将先进的标准转化为已经支持的标准</li></ul></li><li>如何支持新标准<ul><li>原生支持：开发者查看浏览器的支持情况</li><li>Polyfill：以贴近新标准的方式封装API的效果</li><li>转译器：babel</li></ul></li></ul><h5 id="2-ES6的模块"><a href="#2-ES6的模块" class="headerlink" title="2. ES6的模块"></a>2. ES6的模块</h5><ul><li>模块<ul><li>易于拆分，模块加载</li><li>模块化</li></ul></li><li>模块加载规范<ul><li>UMD <ul><li>CommonJS</li><li>AMD</li></ul></li><li>CMD</li></ul></li><li>ES6中的模块加载</li></ul><pre><code class="js">// module1.jsexport default function methodA(){}export default function methodB(){}export default function methodC(){}// module2.jsimport { methodA }from &#39;./module1.js&#39;;</code></pre><ul><li>打包工具<ul><li>browserify、webpack等：</li><li>将多个js模块进行整体打包成一个js文件</li><li>在打包之前需要先使用babel将ES6转化为ES5</li></ul></li></ul><h5 id="3-ES6的Class"><a href="#3-ES6的Class" class="headerlink" title="3. ES6的Class"></a>3. ES6的Class</h5><ul><li>不需要像ES5那样用原型取声明各种方法</li><li>class的typeof值其实也为function</li><li>class内部声明的是实例属性</li><li>ES6实际上是提供了一些语法糖</li></ul><pre><code class="js">class ClassName {  constructor(){}  getName(){    return name;  }}var hh = new ClassName();</code></pre><ul><li>继承<ul><li>ES5特别麻烦，ES6就一个extends就可以了</li></ul></li></ul><h5 id="4-ES6常用特性"><a href="#4-ES6常用特性" class="headerlink" title="4. ES6常用特性"></a>4. ES6常用特性</h5><ul><li>解构赋值</li></ul><pre><code class="js">// 从dataconst {id = 1} = data;</code></pre><ul><li>展开操作符</li></ul><pre><code class="js">//数组展开[1,2,3,...x]//属性展开{a:3,b:4,...c}</code></pre><ul><li>取余</li></ul><pre><code>[a,b,...rest] = [1,2,3,4,5,6]// a = 1// b = 2// rest = [3,4,5,6]</code></pre><ul><li>模板</li></ul><pre><code class="js">`my name is ${name}`</code></pre><ul><li>Set 和 Map<ul><li>类似ES5中的数组和对象</li><li>但是不允许出现元素的重复</li></ul></li></ul><pre><code class="js">var set = new Set([1,2,3,4,4]);set.add(5)var map = new Map([  [&#39;a&#39;,1],  [&#39;b&#39;,2]]);map.put(&#39;c&#39;,3);</code></pre><ul><li>Generator函数和Iterator函数<ul><li>Generator用来实现状态机</li><li>Iterator用来实现迭代和遍历</li></ul></li></ul><h5 id="5-ES6的异步编程"><a href="#5-ES6的异步编程" class="headerlink" title="5.ES6的异步编程"></a>5.ES6的异步编程</h5><ul><li><p>回调函数/事件</p><ul><li>遇到多种回调嵌套的时候写起来会很不友好</li></ul></li><li><p>Promise</p><ul><li>是异步编程的一种解决方案，比传统的基于回调函数和事件的方式更合理和强大</li><li>Promise对象代表一个异步操作，有三种状态<ul><li>Pending：进行中</li><li>Resolved：已完成</li><li>Rejected：已失效</li></ul></li><li>Promise.then()<ul><li>可以接受两个回调函数为参数: then（（resolved, rejected）=&gt;{}）</li><li>then的返回值可以还是一个Promise对象，即仍是一个异步操作。<ul><li>可以采用链式写法，即then方法后再调用另一个then</li><li>后续的回调函数会等到该Promise对象处理完成之后才会被调用</li></ul></li></ul></li></ul><pre><code class="js">// 第一个异步操作function p1 (value){  return new Promise((resolve,reject)=&gt;{    someoperation(value,...)=&gt;{      if(...){        reject();      }else{        resolve(value)      }    })  });}//第二个异步操作function p2 (value){  return new Promise((resolve,reject)=&gt;{    someoperation(value,...)=&gt;{      if(...){        reject();      }else{        resolve(value)      }    })  });}// 按照先1-&gt;2-&gt;1的顺序执行p1(10).then(value =&gt; {  p2(value)}, rej =&gt; {}).then(value =&gt; {  p1(value)}, rej =&gt; {});</code></pre></li><li><p>asyncy异步编程</p><h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h3></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 大脑Cache </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大脑Cache系列--系统地梳理下CSS3技术吧</title>
      <link href="/da-nao-cache/css-ji-zhu-xi-tong-shu-li-2019-10-10.html"/>
      <url>/da-nao-cache/css-ji-zhu-xi-tong-shu-li-2019-10-10.html</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><ul><li>视频云的开发已经进入正常的开发流程了，对前端框架层面已经有了一定的了解，需要返回补充前端核心接触知识了。</li><li>在实际的开发中，调整样式总是花了我前端开发的一大半时间，主要还是对CSS不太熟悉，有必要系统学习一下。</li><li>本文依然按照以往的风格，更注重CSS技术的系统性梳理，不赘述技术细节，因为Google一下就好。</li></ul></blockquote><h3 id="CSS基础"><a href="#CSS基础" class="headerlink" title="CSS基础"></a>CSS基础</h3><h5 id="1-CSS的几种引入方式"><a href="#1-CSS的几种引入方式" class="headerlink" title="1.  CSS的几种引入方式"></a>1.  CSS的几种引入方式</h5><ul><li>head中直接添加文档内样式代码</li></ul><a id="more"></a><pre><code>&lt;style type=&quot;text/css&quot;&gt;{    body{}}&lt;/style&gt;</code></pre><ul><li>head中引入外部样式</li></ul><pre><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;common.css&quot;&gt;</code></pre><ul><li>元素的style样式</li></ul><pre><code>&lt;div style=&quot;width:200px&quot;&gt;</code></pre><h5 id="2-CSS3的几种选择器"><a href="#2-CSS3的几种选择器" class="headerlink" title="2.CSS3的几种选择器"></a>2.CSS3的几种选择器</h5><ul><li>简单选择器（type，#id, .class）</li></ul><pre><code>每个元素的id是唯一的，class可以多个元素同时用选择器组ul, ol {}</code></pre><ul><li>属性选择器</li></ul><pre><code>.class[width = 200px]{}</code></pre><ul><li>上下文选择器</li><li>伪类选择器</li></ul><pre><code>//结构化伪类选择器e:first-child{} //第一个子元素设置e:last-child{}e:nth-child(2n+1){} //奇数位置元素//UI伪类选择器e:visited{}hover,focus,active, checked</code></pre><ul><li>伪元素选择器</li></ul><h5 id="3-CSS的级联Casscading"><a href="#3-CSS的级联Casscading" class="headerlink" title="3. CSS的级联Casscading"></a>3. CSS的级联Casscading</h5><ul><li>级联：一个元素可能会被多个CSS选择器选中，就会产生层叠/级联效果。</li><li>优先级规则算法：</li></ul><pre><code>1. 首先会判断重要性important    a {        color:blue; !important    }2. 规则来源： 开发者设置 &gt; 用户设置  &gt; 浏览器预设2. 基于明确程度，ID &gt; Class &gt; Type , 算法通过（I-C-T）分量来判断3. 顺序：后添加的生效</code></pre><h5 id="4-CSS的继承"><a href="#4-CSS的继承" class="headerlink" title="4. CSS的继承"></a>4. CSS的继承</h5><ul><li>子元素会继承来自父元素的属性</li><li>不是所有的属性都是可继承的</li></ul><h5 id="5-厂商前缀"><a href="#5-厂商前缀" class="headerlink" title="5. 厂商前缀"></a>5. 厂商前缀</h5><ul><li>为了解决不同厂商的浏览器的兼容问题</li><li>常见的厂商前缀</li></ul><pre><code>Chrome:     -webkitFirefox:    -mozOpera:      -oSafari:     -webkit</code></pre><h3 id="CSS布局"><a href="#CSS布局" class="headerlink" title="CSS布局"></a>CSS布局</h3><h5 id="1-float"><a href="#1-float" class="headerlink" title="1. float"></a>1. float</h5><h5 id="2-Postion定位"><a href="#2-Postion定位" class="headerlink" title="2. Postion定位"></a>2. Postion定位</h5><h5 id="3-Flex"><a href="#3-Flex" class="headerlink" title="3. Flex"></a>3. Flex</h5><p>内容</p><h3 id="CSS高级"><a href="#CSS高级" class="headerlink" title="CSS高级"></a>CSS高级</h3><h5 id="1-媒体查询"><a href="#1-媒体查询" class="headerlink" title="1. 媒体查询"></a>1. 媒体查询</h5><ul><li>用来实现响应式布局控制</li><li>类似编程语言中的if语句</li><li>指定一组媒体条件，在满足所有媒体条件的时候，应用新的样式规则</li></ul><pre><code>@media(max-width:600px) and (width&lt;=600px) and (mf2) {    prestyle{        new style    }    rules{    }}</code></pre><p>开源库：<a href="https://github.com/scottjehl/Respond/" target="_blank" rel="noopener">Respond.js</a></p><h5 id="2-mobile-first-的响应式设计"><a href="#2-mobile-first-的响应式设计" class="headerlink" title="2. mobile first 的响应式设计"></a>2. mobile first 的响应式设计</h5><ul><li>之前的实现都是宽屏优先的，初始样式是面向宽屏的。</li><li>移动优先的初始设计是面向手机设备，然后对逐渐宽屏进行响应式设计。</li><li>优点：移动端是趋势，移动设备加载更快，在移动设备上不会去下载宽屏的样式文件。</li></ul><pre><code>css rules for mobile device ...@media screen and (min-width:768px){    rule1    rule2}// 769px小屏， 972px中屏，1200px大屏</code></pre><h5 id="3-CSS3的Transform"><a href="#3-CSS3的Transform" class="headerlink" title="3. CSS3的Transform"></a>3. CSS3的Transform</h5><ul><li>为元素添加变形和变换效果，2D和3D</li><li>行内元素（inline）不是transformable元素，其他常见的都是的</li><li>Transform 对于元素的内容，边框，边距等都会生效。</li><li>实质上是进行矩阵变换</li><li>默认以元素的中心为Transform的基点，可以通过transform-origin更改</li><li>几个基本操作</li></ul><pre><code>transform: rotate(45deg);   //旋转45度，度数可以是负数transform: scale(x-value,y-value); //x,y方向上的缩放transform: translate(x-value,y-value)//在xy上移动transform: skew(45deg,45deg)   //x和y方向上倾斜度数transform: rotate(45deg) scale(3);  //多个transform组合使用，需要注意的是从右向左生效的transform-origin: left top; //将Transform的基点变成左上角</code></pre><h5 id="4-CSS3的Transition"><a href="#4-CSS3的Transition" class="headerlink" title="4. CSS3的Transition"></a>4. CSS3的Transition</h5><ul><li>用于给文档中的样式变化添加过渡效果</li><li>不是所有的CSS属性都可以添加过渡效果</li></ul><pre><code>transition-property: width, background-color;     //设置transition关注的属性值的变化transition-property: all;       //为所有的可添加属性添加transition效果transition-duration: 3s, 1ms;        //各个属性平滑过渡效果的持续时长transition-delay：1s, 2ms;      //执行过渡效果动画的等待时间transition-timing-function: linear | ease-in | ease-out | ease-in-out | ease; //设置渐变的时间函数(常用的5个)transition: property duration func delay;       // 简写属性</code></pre><h5 id="6-CSS3的Animation"><a href="#6-CSS3的Animation" class="headerlink" title="6. CSS3的Animation"></a>6. CSS3的Animation</h5><ul><li>与Transition的不同：Animation可以支持一个系列的变化，而Transition只能实现从一个状态过渡到另一个</li><li>实现本质方式：指定元素在动画中的关键帧状态</li><li>例子： 实现弹球动画</li></ul><pre><code>// 先定义了一个动画序列效果@Keyframes bounce {         0% {        left: 0px;        top: 0px;    }    0% {        left: 50px;        top: 100px;    }    0% {        left: 100px;        top: 0px;    }}// 应用动画序列效果.box:hover .ball {    animation: bounce 4s linear 0s;     //鼠标悬停的时候触发动画}</code></pre><ul><li>动画循环次数属性：animation-iteration-count</li><li>动画方向属性：animation-direction</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>内容</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 大脑Cache </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BroswerRouter以及HashRouter的React前端项目在Nginx上部署</title>
      <link href="/ji-zhu/broswerrouter-yi-ji-hashrouter-de-react-qian-duan-xiang-mu-zai-nginx-shang-bu-shu-2019-09-28.html"/>
      <url>/ji-zhu/broswerrouter-yi-ji-hashrouter-de-react-qian-duan-xiang-mu-zai-nginx-shang-bu-shu-2019-09-28.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>背景：视频云的前端项目使用了React框架，并通过React-Router实现了SPA单页应用。前端包括管理端和观看端，而React-Router有两种常用类型的Router，分别是HashRouter以及BrowserRouter，为了体验二者的不同，在管理端使用了HashRouter，而在观看端使用了HashRouter。</p></blockquote><h3 id="两种React-Router"><a href="#两种React-Router" class="headerlink" title="两种React-Router"></a>两种React-Router</h3><h5 id="1-HashRouter"><a href="#1-HashRouter" class="headerlink" title="1. HashRouter"></a>1. HashRouter</h5><ul><li>history: 使用 hash history</li><li>通过Hash部分来表示路由，属于浏览器端路由，Hash部分在请求的时候并不会提交到服务器，也就是说不管是请求 #foo 还是 #bar ，服务只知道请求了 index.html 并不知道 hash 部分的细节。</li><li>url样例：/#/user</li><li>不需要服务器支持，由浏览器负责路由。</li></ul><a id="more"></a><h5 id="2-BrowserRouter"><a href="#2-BrowserRouter" class="headerlink" title="2. BrowserRouter"></a>2. BrowserRouter</h5><ul><li>使用的是 HTML5 的 History API，浏览器提供相应的接口来修改浏览器的历史记录</li><li>需要服务器支持，属于服务器路由</li><li>url样例：/user/lives</li><li>路由直接在URL中，原则上每次URL切换的时候，都会像服务器请求页面</li><li>但借助html5里面history的新的api，可以使用js改变url的值，而不会向服务端发请求。(刷新界面的时候还是会请求页面)</li><li>是react-router官方推荐的</li></ul><h3 id="使用Nginx部署的时候需要特殊的配置"><a href="#使用Nginx部署的时候需要特殊的配置" class="headerlink" title="使用Nginx部署的时候需要特殊的配置"></a>使用Nginx部署的时候需要特殊的配置</h3><ul><li>传统的前端部署之后，浏览器都是直接通过浏览器地址栏中的uri去请求服务器对应位置的文件，而在使用React-Router进行路由管理来实现SPA之后，依然采用这样的配置的话，初次加载首页是正常的，但当浏览器URI被改变之后，再点击刷新，则页面不显示或者404错误。</li><li>原因在于，使用React-Router之后，页面内的路由是由前端自行渲染的，未通过后端，而是js动态更改了location。而当我们刷新界面时，首先访问的是后台地址，然后在返回的页面中再去加载React代码并执行。</li><li>问题在于，React应用在运行的时候可能会去更改浏览器的URL，而实际服务器上可能并不存在与URI对应的资源（因为资源的定位已经交给React来做了），所以刷新页面的时候，浏览器直接用URI去寻找资源，可想而知会产生异常（404或者不显示）。</li><li>而我们使用Webpack来打包React之后，最终的输出就是一个index.html附加一些文件，当然文件的定位逻辑也存在这些文件中。所以，默认的由Nginx服务器来定位这些资源的方式是行不通的，需要将该任务交给React本身来做。</li><li>所以，思路是，浏览器在使用React应用期间，无论URI是否更改，服务器都直接无脑返回index.html这个页面就可以，浏览器得到index.html，加载React，剩下的任务都交给React本身去做就好了。</li><li>使用Nginx的try_files，来将前端的请求都映射到index.html。</li></ul><h3 id="部署HashRouter的Nginx配置"><a href="#部署HashRouter的Nginx配置" class="headerlink" title="部署HashRouter的Nginx配置"></a>部署HashRouter的Nginx配置</h3><ul><li>在Nginx中配置一个vhost</li></ul><pre><code class="bash"># nginx.conf整体配置大概如下：server {    listen 8083;    root /home/name/..../build; # 前端build完成之后的静态资源路径    index index.html index.htm;    location / {        try_file $uri $uri/ /index.html;  # url 切换时始终返回index.html    }    # 其他配置    # 图片样式缓存1年    location ~* /app.*\.(js|css|png|jpg)$ {       access_log off;        expires    365d;    }    # html/xml/json 文件不缓存    location ~* /app.*\.(?:manifest|appcache|html?|xml|json)$ {        expires    -1;    }}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>部署项目的时候搞得很头痛和低效，深入搞明白之后，再也不怕React前端的部署了。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>1.<a href="https://www.cnblogs.com/soyxiaobi/p/11096940.html" target="_blank" rel="noopener">react-router-dom下的BrowserRouter和HashRouter</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搞定跨域资源共享CORS（笔记整理）</title>
      <link href="/ji-zhu/gao-ding-kua-yu-zi-yuan-gong-xiang-cors-bi-ji-zheng-li-2019-09-23.html"/>
      <url>/ji-zhu/gao-ding-kua-yu-zi-yuan-gong-xiang-cors-bi-ji-zheng-li-2019-09-23.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>当从一个域向另一个不同的域或者端口请求资源的时候，会产生跨域请求。<br><img src="http://zwboy.oss-cn-beijing.aliyuncs.com/blog/kuayu.png" alt="跨域.png"></p></blockquote><h3 id="一、什么是跨域"><a href="#一、什么是跨域" class="headerlink" title="一、什么是跨域"></a>一、什么是跨域</h3><ol><li>同源政策（same origin policy）：协议，主机名和端口号要相同，否则就会产生跨域请求。</li><li>通常的错误形式：Access to XMLHttpRequest at XXX has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource.</li><li>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</li><li>出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求（或者跨域响应被拦截）。比如XMLHttpRequest和Fetch API都需要遵循同源策略。</li><li>实现CORS必须要在服务器端实现CORS接口，即响应报文包含了正确CORS响应头。</li></ol><a id="more"></a><h3 id="二、为何要限制跨域"><a href="#二、为何要限制跨域" class="headerlink" title="二、为何要限制跨域"></a>二、为何要限制跨域</h3><blockquote><p>跨站请求攻击CSRF<br><img src="http://zwboy.oss-cn-beijing.aliyuncs.com/blog/csrf.png" alt="CSRF.png"></p></blockquote><ol><li>攻击者引导用户去登录访问正常的网站，比如银行，session_id等认证会留在浏览器中。</li><li>同时用户还在访问攻击者提供的网站，但是该网站会自动或者通过点击触发向之前正常的网站发起请求，当然用了之前已经认证过的session_id。</li><li>这样就在用户不知道的情况下进行了一些诸如发送邮件，甚至转账、购买商品等操作。</li><li>其利用的是Web用户身份验证的漏洞，即，简单的身份验证智能保证请求是来自该用户的浏览器（不是其他人在另一个浏览器伪造），但是并不能保证请求是用户本身自愿发出的。</li><li>同源政策将会确保网站a拒绝来自网站b的请求。</li></ol><h3 id="三、为何又需要跨域呢"><a href="#三、为何又需要跨域呢" class="headerlink" title="三、为何又需要跨域呢"></a>三、为何又需要跨域呢</h3><blockquote><p>前后端分离</p></blockquote><p>当前端框架兴起之后，前后端彻底分离的开发方式渐渐流行。前端和后端往往部署在不同的域名之上。前端通过访问后端的API获取数据，渲染前端界面，甚至进行路由跳转。这通常意味着前后端会出现不同源的问题。因为即使部署在同一台主机上，二者也属于不同的端口。那么我们就需要某种策略使得跨域请求能够通过。</p><h3 id="四、跨域请求过程"><a href="#四、跨域请求过程" class="headerlink" title="四、跨域请求过程"></a>四、跨域请求过程</h3><blockquote><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p></blockquote><h5 id="1-简单请求的跨域过程"><a href="#1-简单请求的跨域过程" class="headerlink" title="1. 简单请求的跨域过程"></a>1. 简单请求的跨域过程</h5><ul><li>1.1. 简单请求是什么</li></ul><blockquote><ol><li>请求方法是以下三种方法之一（简单方法）：HEAD，GET，POST</li><li>HTTP的头信息不超出以下几种字段（简单头）：Accept，Accept-Language，Content-Language，Last-Event-ID，Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li></ol></blockquote><ul><li>1.2. 跨域过程</li></ul><blockquote><ol><li>浏览器检测到这是一个简单请求，会自动在Header中添加Origin字段，该字段描述了协议，域名以及端口的信息。</li><li>服务器会检查Origin，如果不在许可范围内（allow-origin），就会返回一个正常的HTTP回应，浏览器会抛出异常。如果在，服务器会返回响应，响应Header中会怎加几个头信息字段。<pre><code class="js">Access-Control-Allow-Origin:* //服务器接收的originAccess-Control-Allow-Credentials: true // 服务器是否允许CORS请求中发送Cookie。//如果想实现发送Cookie的话，还需要在浏览器端设置withCredentials = true;Access-Control-Expose-Headers: // ResponsHeader中暴露的字段</code></pre></li></ol></blockquote><h5 id="2-非简单请求的跨域过程"><a href="#2-非简单请求的跨域过程" class="headerlink" title="2. 非简单请求的跨域过程"></a>2. 非简单请求的跨域过程</h5><blockquote><p>比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json，含有自定义的请求头等。</p></blockquote><ul><li>Step.1. 预检请求Preflight</li></ul><blockquote><p>旨在确保服务器对 CORS 标准知情，以保护不支持 CORS 的旧服务器</p><ol><li>浏览器发现是非简单请求，会在正式的通信之前，先向服务器询问当前网页所在的域名是否在服务器的许可名单中，以及可以使用哪些HTTP动词。</li><li>预检请求是一个OPTION请求，会携带Access-Control-Request-Method（指明该跨域请求的Method），Access-Control-Request-Headers（该跨域请求额外会发送的头信息字段，比如认证字段）以及Origin信息。</li><li>服务器检查以上三个字段，确认允许后就会做出回应。（服务器在设置跨域请求的时候不能忘记对预检请求的处理）。回应Header包括Access-Control-Allow-Methods，Access-Control-Allow-Headers，Access-Control-Allow-Credentials等。</li></ol></blockquote><ul><li>Step.2. 预检成功后再发起跨域请求</li></ul><blockquote><p>预检通过之后，浏览器会像简单请求一样，再发送正式的CORS请求。<br><img src="http://zwboy.oss-cn-beijing.aliyuncs.com/blog/cros-yujian.png" alt="d"></p></blockquote><h3 id="五、服务器配置CORS"><a href="#五、服务器配置CORS" class="headerlink" title="五、服务器配置CORS"></a>五、服务器配置CORS</h3><p>以nodejs koa为例，如下为koa corszho</p><pre><code>const URL = require(&#39;url&#39;);/** * 关键点： * 1、如果需要支持 cookies, *    Access-Control-Allow-Origin 不能设置为 *, *    并且 Access-Control-Allow-Credentials 需要设置为 true *    (注意前端请求需要设置 withCredentials = true) * 2、当 method = OPTIONS 时, 属于预检(复杂请求), 当为预检时, 可以直接返回空响应体, 对应的 http 状态码为 204 * 3、通过 Access-Control-Max-Age 可以设置预检结果的缓存, 单位(秒) * 4、通过 Access-Control-Allow-Headers 设置需要支持的跨域请求头 * 5、通过 Access-Control-Allow-Methods 设置需要支持的跨域请求方法 */module.exports = async function (ctx, next) {    const origin = URL.parse(ctx.get(&#39;origin&#39;) || ctx.get(&#39;referer&#39;) || &#39;&#39;);    if (origin.protocol &amp;&amp; origin.host) {        ctx.set(&#39;Access-Control-Allow-Origin&#39;, `${origin.protocol}//${origin.host}`);        ctx.set(&#39;Access-Control-Allow-Methods&#39;, &#39;POST, GET, OPTIONS, DELETE, PUT&#39;);        ctx.set(&#39;Access-Control-Allow-Headers&#39;, &#39;X-Requested-With, User-Agent, Referer, Content-Type, Cache-Control,accesstoken&#39;);        ctx.set(&#39;Access-Control-Max-Age&#39;, &#39;86400&#39;);        ctx.set(&#39;Access-Control-Allow-Credentials&#39;, &#39;true&#39;);    }    if (ctx.method !== &#39;OPTIONS&#39;) {        // 如果请求类型为非预检请求，则进入下一个中间件（包括路由中间件等）        await next();    } else {        // 当为预检时，直接返回204,代表空响应体        ctx.body = &#39;&#39;;        ctx.status = 204;    }};</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在开发前端的过程中CROS问题总是让自己很头痛，前期花费了大量时间解决CROS问题。再了解了CROS的原理和过程后，对跨域问题不再畏惧。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ol><li><a href="https://segmentfault.com/a/1190000015017666" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015017666</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">HTTP访问控制（CORS）</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在一台服务器上通过Nginx反向代理配置多个二级域名映射多个不同端口的应用</title>
      <link href="/ji-zhu/zai-yi-tai-fu-wu-qi-shang-tong-guo-nginx-pei-zhi-duo-ge-er-ji-yu-ming-ying-she-duo-ge-bu-tong-duan-kou-de-ying-yong.html"/>
      <url>/ji-zhu/zai-yi-tai-fu-wu-qi-shang-tong-guo-nginx-pei-zhi-duo-ge-er-ji-yu-ming-ying-she-duo-ge-bu-tong-duan-kou-de-ying-yong.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>背景：需要在实验室服务器上部署gitlab，jira，jenkins等等Server服务，这些服务工作在不同的端口，无法直接通过http的80端口访问，所以之前是通过IP+端口号的方式进行访问。在申请了自己的一个域名之后，想要通过多个二级域名来访问。</p></blockquote><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>能够通过gitlab.domain.cn访问绑定在82端口上的gitlab服务，通过jenkins.domain.cn访问绑定在9090端口上的jenkins服务。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>1.在域名的解析中分别添加gitlab, jenkins,以及www三个记录，指向均为实验室服务器的IP地址。</li><li>2.使用Nginx作为代理服务器，监听80端口，通过server_name进行匹配，将请求转发到对应的应用服务器。(这应该属于Nginx的反向代理功能，即为多个服务提供代理服务)</li></ul><a id="more"></a><h4 id="实际解决"><a href="#实际解决" class="headerlink" title="实际解决"></a>实际解决</h4><ul><li>1.编辑Nginx配置信息（Ubuntu）<pre><code class="bash"># 配置文件路径：/etc/nginx/conf.d/domain.conf，（没有的话需要创建）# Nginx会自动include /etc/nginx/conf.d 目录下所有以.conf结尾的配置到主配置文件nginx.conf中.</code></pre></li></ul><h1 id="起一个服务，端口80"><a href="#起一个服务，端口80" class="headerlink" title="起一个服务，端口80"></a>起一个服务，端口80</h1><p>server {<br>        listen 80;  # 设置Nginx对外监听80端口<br>        server_name <em>.domain.cn;  # 绑定到该服务器的域名<br>        if ( $http_host ~</em> “^(.<em>?).domain.cn” ) {  # 对http_host进行正则匹配，解析domain<br>                set $domain $1;<br>        }<br>        location / {<br>                proxy_set_header        X-Real-IP       $remote_addr;<br>                proxy_set_header        Host            $http_host;<br>                # 分别处理各个domain<br>                if ( $domain ~</em> “www” ) {<br>                        proxy_pass <a href="http://localhost:82" target="_blank" rel="noopener">http://localhost:82</a>;  # 通过proxy_pass 进行代理转发<br>                }<br>                if ( $domain ~* “gitlab” ) {<br>                        proxy_pass <a href="http://localhost:82" target="_blank" rel="noopener">http://localhost:82</a>;<br>                }<br>                if ( $domain ~* “jenkins” ) {<br>                        proxy_pass <a href="http://localhost:9090" target="_blank" rel="noopener">http://localhost:9090</a>;<br>                }<br>        }</p><p>}</p><pre><code>- 2.检查配置文件合法性```bash# 需要将nginx添加到环境变量中sudo nginx -t</code></pre><ul><li>3.更新Nginx配置<pre><code class="bash">sudo nginx -s reload</code></pre></li></ul><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><ul><li>可以为多个相同的后端服务在反向代理的同时实现负载均衡</li></ul><pre><code class="bash"># 配置jenkins负载均衡upstream jenkins {      # 默认负载均衡规则为轮询       server      http://localhost:9090 weight = 5;      # 可以设置权重      server      http://10.10.x.x:9090 weight = 1;}server {        listen 80;  # 设置Nginx对外监听80端口        server_name *.domain.cn;  # 绑定到该服务器的域名，server也可以是正则表达式        if ( $http_host ~* &quot;^(.*?)\.domain\.cn&quot; ) {  # 对http_host进行正则匹配，解析domain                set $domain $1;        }        location / {                proxy_set_header        X-Real-IP       $remote_addr;                proxy_set_header        Host            $http_host;     # 不可缺，否则无法代理                # 分别处理各个domain                if ( $domain ~* &quot;gitlab&quot; ) {                        proxy_pass http://jenkins;                }                if ( $domain ~* &quot;jenkins&quot; ) {                        proxy_pass http://localhost:9090;                }        }}</code></pre><h4 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h4><p>最开始的思路是在Nginx中配置多个server块，再每个块中再配置proxy_pass来实现，配置文件如下。</p><pre><code class="bash"># jenkins.domain.cn.confserver {        listen 80;  # 设置Nginx对外监听80端口        server_name jenkins.domain.cn;          proxy_pass http://localhost:9090;}</code></pre><pre><code class="bash"># gitlab.domain.cn.confserver {        listen 80;  # 设置Nginx对外监听80端口        server_name gitlab.domain.cn;          proxy_pass http://localhost:82;}</code></pre><p>Reload Nginx之后发现，二级域名是失效的，两个域名均指向的是gitlab，无法实现想要的效果。分析应该是gitlab.domain.cn.conf先被include到nginx.conf中（和文件顺序有关），所以生效的是gitlab吧。<br>不确定，还需要进一步研究。<br>2019.12.12，问题解决，（果然是按照配置文件顺序匹配的）</p><ul><li>当时咋想的，两个server listen同一个端口</li><li>另外，Nginx 中server的匹配顺序如下<ul><li>1.精确匹配</li><li>2.匹配*.zwboy.cn这样的泛域名</li><li>3.按照文件顺序匹配</li><li>4.都没匹配，则匹配第一个，或者listen设置为default的server<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4>Nginx是个强大的工具，可以作为Web服务器，文件服务器，代理服务器，反向代理服务器，直播服务器，负载均衡服务器等等，值得深入学习。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> 反向代理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
